<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>BUAAOS-Lab6 Challenge | B1fang的闲人屋</title><meta name="author" content="B1fang"><meta name="copyright" content="B1fang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="看看我的Shell！ 实现记录由于我选择的是Lab6的挑战性任务，整体的子任务数较多，本人能力所限无法用一条完整的思路串联起所有的子任务，故为该节起名为：记录，还请看官海涵。这一部分基本按照osome平台上的任务顺序组织（虽然与实际实现历程有一定差异，我为了更方便对这些拓展功能进行测试，实际上先完成了对命令编辑功能的优化）。 实现由;分隔的一行多命令由于分号已经在sh.c中以宏定义的形式被加入到保">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAAOS-Lab6 Challenge">
<meta property="og:url" content="https://b1fang.github.io/2023/06/16/OS-Challenge/index.html">
<meta property="og:site_name" content="B1fang的闲人屋">
<meta property="og:description" content="看看我的Shell！ 实现记录由于我选择的是Lab6的挑战性任务，整体的子任务数较多，本人能力所限无法用一条完整的思路串联起所有的子任务，故为该节起名为：记录，还请看官海涵。这一部分基本按照osome平台上的任务顺序组织（虽然与实际实现历程有一定差异，我为了更方便对这些拓展功能进行测试，实际上先完成了对命令编辑功能的优化）。 实现由;分隔的一行多命令由于分号已经在sh.c中以宏定义的形式被加入到保">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b1fang.github.io/images/covers/cover3.jpg">
<meta property="article:published_time" content="2023-06-16T15:20:44.000Z">
<meta property="article:modified_time" content="2023-06-16T15:43:18.369Z">
<meta property="article:author" content="B1fang">
<meta property="article:tag" content="bash">
<meta property="article:tag" content="Operating System">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b1fang.github.io/images/covers/cover3.jpg"><link rel="shortcut icon" href="/images/heads/icon1.png"><link rel="canonical" href="https://b1fang.github.io/2023/06/16/OS-Challenge/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"09JN05OKYZ","apiKey":"ae02bbf0927e7ca61e8dd71abf90c88e","indexName":"b1fang_blog_content","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAAOS-Lab6 Challenge',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-16 23:43:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/heads/head1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 内容时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 我是？</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 类目</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/covers/cover3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">B1fang的闲人屋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 内容时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 我是？</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 类目</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAAOS-Lab6 Challenge</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-16T15:20:44.000Z" title="发表于 2023-06-16 23:20:44">2023-06-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-16T15:43:18.369Z" title="更新于 2023-06-16 23:43:18">2023-06-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/BUAA-OS/">BUAA-OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAAOS-Lab6 Challenge"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="看看我的Shell！"><a href="#看看我的Shell！" class="headerlink" title="看看我的Shell！"></a>看看我的Shell！</h2><p><img src="shell.jpg" alt="shell"></p>
<h2 id="实现记录"><a href="#实现记录" class="headerlink" title="实现记录"></a>实现记录</h2><p>由于我选择的是Lab6的挑战性任务，整体的子任务数较多，本人能力所限无法用一条完整的思路串联起所有的子任务，故为该节起名为：<strong>记录</strong>，还请看官海涵。这一部分基本按照<code>osome</code>平台上的任务顺序组织（虽然与实际实现历程有一定差异，我为了更方便对这些拓展功能进行测试，实际上先完成了对命令编辑功能的优化）。</p>
<h3 id="实现由-分隔的一行多命令"><a href="#实现由-分隔的一行多命令" class="headerlink" title="实现由;分隔的一行多命令"></a>实现由<code>;</code>分隔的一行多命令</h3><p>由于分号已经在<code>sh.c</code>中以宏定义的形式被加入到<strong>保留符号</strong>了，故只需要修改<code>parsecmd()</code>函数使其增添对于<code>&#39;;&#39;</code>这一符号的处理能力即可。</p>
<p>本功能的具体思路就是当解析遇到一个’;’符号后，<code>fork</code>一个子shell，让子shell继续执行左边的命令，父shell等待子shell执行完成后，执行’;’符号右边的命令，具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:;</span><br><span class="line">	<span class="type">int</span> child = fork(); <span class="comment">// fork出两个进程</span></span><br><span class="line">	<span class="keyword">if</span>(child) &#123; <span class="comment">// 父进程等待子进程执行完再执行&#x27;;&#x27;右边的命令</span></span><br><span class="line">		<span class="keyword">if</span>(re_alloc == <span class="number">0</span>)&#123; <span class="comment">// 如果前一条命令出现了重定向，那么再重定向回来</span></span><br><span class="line">			dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(re_alloc == <span class="number">1</span>) &#123;</span><br><span class="line">			dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        wait(child);</span><br><span class="line">		<span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程执行&#x27;;&#x27;左边的命令</span></span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="实现-amp-后缀的shell后台任务"><a href="#实现-amp-后缀的shell后台任务" class="headerlink" title="实现&amp;后缀的shell后台任务"></a>实现<code>&amp;</code>后缀的shell后台任务</h3><p>其实本功能和上一项的实现较为类似，只是增加了一点要求：我们的shell只需要等待’&amp;’右侧的命令的执行完毕，而左侧的命令处于“<strong>后台运行</strong>”状态，shell进程无需等待。与对’;’的处理相似，我们对<code>parsecmd()</code>做如下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe, <span class="type">int</span> *_wait)</span>&#123; <span class="comment">// 为函数头添加 int *_wait参数，用于指示当前执行的程序是否需要cmd进行等待</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:;</span><br><span class="line">        <span class="type">int</span> child_ = fork();</span><br><span class="line">        <span class="keyword">if</span>(child_) &#123; <span class="comment">// 父进程执行右边的命令</span></span><br><span class="line">            <span class="keyword">if</span>(re_alloc == <span class="number">0</span>)&#123; <span class="comment">// 如果前一条命令出现了重定向，那么再重定向回来</span></span><br><span class="line">				dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(re_alloc == <span class="number">1</span>) &#123;</span><br><span class="line">				dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            *_wait = <span class="number">1</span>; <span class="comment">// 需要shell等待</span></span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe, _wait);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程执行左边的命令</span></span><br><span class="line">            *_wait = <span class="number">0</span>; <span class="comment">// 不需要shell等待</span></span><br><span class="line">            <span class="keyword">return</span> argc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到与’;’的实现不同点在于父子进程没有通过调用<code>wait()</code>函数进行互相的等待，这是因为后台指令理论上是与前台指令并发的，同时，我们新增了<code>_wait</code>这个<code>int</code>型的指针，它的用法是在<code>runcmd()</code>中告知程序是否需要对当前执行程序进行等待，我们对<code>runcmd()</code>函数的具体修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _wait = <span class="number">1</span>; <span class="comment">// 默认是需要等待的</span></span><br><span class="line"><span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br><span class="line">close_all();</span><br><span class="line"><span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(_wait)&#123;</span><br><span class="line">        wait(child); <span class="comment">// 在需要等待时等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这只是在cmd层面实现了该指令，但是我们的<code>mos</code>内核存在一些小问题影响了该功能的运行效果，该问题的解决我们放在最后一部分<strong>问题&amp;解决方案</strong>来讲。</p>
<h3 id="实现引号包裹的字符串的支持"><a href="#实现引号包裹的字符串的支持" class="headerlink" title="实现引号包裹的字符串的支持"></a>实现引号包裹的字符串的支持</h3><p>对引号的支持可以在<strong>词法解析</strong>时实现，其本质就是在词法解析时将两个引号间的字符串<strong>看作一个词法单元</strong>，具体实现我们可以在<code>_gettoken()</code>函数中增加如下部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123; <span class="comment">// 识别引号</span></span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">    s++;</span><br><span class="line">    *p1 = s;</span><br><span class="line">    <span class="keyword">while</span>(*s &amp;&amp; (*s != <span class="string">&#x27;\&quot;&#x27;</span>))&#123;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    *s++ = <span class="number">0</span>;</span><br><span class="line">    *p2 = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;s&#x27;</span>; <span class="comment">// it means &quot;string&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在修改<code>_gettoken()</code>函数时遇到了一点小bug，我第一次写的时候没有将字符串末尾引号置为’\0’，导致实际运行过程中会将前引号之后的所有内容都视为一个字符串，修改后就没问题了。</p>
<p>并在<code>parsecmd()</code>函数中增加针对于字符串此法单元的判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= MAXARGS) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;too many arguments\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc++] = t;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="实现键入命令时任意位置的修改-amp-实现历史命令功能"><a href="#实现键入命令时任意位置的修改-amp-实现历史命令功能" class="headerlink" title="实现键入命令时任意位置的修改 &amp; 实现历史命令功能"></a>实现键入命令时任意位置的修改 &amp; 实现历史命令功能</h3><p><strong>这真的是我做的最痛苦的一块了</strong>，<del>真的是在bug里面找代码</del>。由于均牵涉到方向键的处理，所以我把这两个任务放在一起了。</p>
<p>首先，查阅资料可知，<strong>上下左右</strong>键在linux中的编码为：</p>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">上</td>
<td align="center">27 ‘[‘ ‘A’</td>
</tr>
<tr>
<td align="center">下</td>
<td align="center">27 ‘[‘ ‘B’</td>
</tr>
<tr>
<td align="center">左</td>
<td align="center">27 ‘[‘ ‘D’</td>
</tr>
<tr>
<td align="center">右</td>
<td align="center">27 ‘[‘ ‘C’</td>
</tr>
</tbody></table>
<p>也就是说，当我们在linux系统下，在键盘下按下一个方向键，就拿’↑’举例子吧，就会往缓冲区顺序写入三个字符，分别是<code>ascii[27]</code>，’[‘以及’A’。</p>
<p>基于上述理解，我们对shell的命令编辑体验进行优化。</p>
<h4 id="对readline函数的逻辑进行重构"><a href="#对readline函数的逻辑进行重构" class="headerlink" title="对readline函数的逻辑进行重构"></a>对readline函数的逻辑进行重构</h4><p>首先，我们将从stdin读入进来的字符分为五类：</p>
<ul>
<li>上下方向键(具体编码见上)</li>
<li>左右方向键(具体编码见上)</li>
<li>退格键(‘\b’)</li>
<li>回车键(‘\n’ || ‘\r’)</li>
<li>可见ascii码(其它情况)</li>
</ul>
<p>对于我们的buf数组，我们需要一个标定其下一次插入位置的整形变量<code>i</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;<span class="comment">// 指示当前编辑位置的指针变量</span></span><br><span class="line">    buf[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> char_num = <span class="number">0</span>; <span class="comment">// 当前插入的字符数</span></span><br><span class="line">    <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(char_num &lt;= n) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>); <span class="comment">// 从缓冲区中读入下一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&#x27;\n&#x27;</span> || tmp == <span class="string">&#x27;\r&#x27;</span>) &#123; <span class="comment">// 读入了换行符则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="number">27</span>) &#123;</span><br><span class="line">            <span class="comment">// 方向键逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\b&#x27;</span> || buf[i] == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在插入位置插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    debugf(<span class="string">&quot;line too long\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((r = read(<span class="number">0</span>, buf, <span class="number">1</span>)) == <span class="number">1</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 读空缓冲区，忽略已输入内容</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="支持光标左右移动进行相应位置的插入与删除"><a href="#支持光标左右移动进行相应位置的插入与删除" class="headerlink" title="支持光标左右移动进行相应位置的插入与删除"></a>支持光标左右移动进行相应位置的插入与删除</h4><p>首先是<code>buf</code>层面的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp == <span class="string">&#x27;D&#x27;</span>) &#123; <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c[C&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">&#x27;C&#x27;</span>) &#123; <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="built_in">strlen</span>(buf)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c[D&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="comment">// 如果已经指向末尾，不必移动</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是回显逻辑就相对来说比较麻烦，我们应当针对左、右、删、插操作设置相应的回显。</p>
<p>其实左键和右键并不需要处理，光标单纯的左右移动并不需要我们来操心，我们只需要关心进行删除和插入的时候如何进行回显。</p>
<p>最终我采取了这样每次插入和删除操作后都进行刷新的做法，<del>虽然效率比较低而且频闪比较高</del>，总结下来主要有以下几步：</p>
<ul>
<li>移动光标到被编辑指令的末尾</li>
<li>输出<strong>足够的</strong>“\b \b”删除旧命令</li>
<li>输出新命令</li>
<li>维护光标到编辑位置</li>
</ul>
<p>具体代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(modify) &#123; <span class="comment">// 如果发生了删改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = old_i; x &lt; old_cn; x++)&#123; <span class="comment">// 移动光标到最后</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; old_cn; x++)&#123; <span class="comment">// 清除本行内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\b \b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">// 输出新内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = i; x &lt; char_num; x++)&#123; <span class="comment">// 维护光标位置</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[D&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>鬼知道这个回显我调了多少次</del>。</p>
<h4 id="支持上下键对历史记录的查询"><a href="#支持上下键对历史记录的查询" class="headerlink" title="支持上下键对历史记录的查询"></a>支持上下键对历史记录的查询</h4><p>对于打好<code>readline()</code>框架和已经实现文件创建接口的我们来说并不是一件困难的事情。</p>
<p>为了对我们在根目录下保存历史记录的<code>.history</code>文件进行初始化以及读写操作，我们在用户库的<code>history.c</code>文件里编写了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_history</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_history</span><span class="params">(<span class="type">char</span> *cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_history</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> direction)</span>; <span class="comment">// direction == 1时上移，direction == 0时下移</span></span><br></pre></td></tr></table></figure>

<p>并在根目录下编写了<code>history.c</code>文件以烧录进MOS中以实现列出所有历史命令的<code>history</code>命令。</p>
<p>最后的要做的就是在我们的<code>readline()</code>函数里面写好调用逻辑就好：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">// 上</span></span><br><span class="line">    modify = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c[B&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">    read_history(buf, <span class="number">1</span>); <span class="comment">// 读取历史命令</span></span><br><span class="line">    old_cn = char_num; <span class="comment">// 维护这些状态变量</span></span><br><span class="line">    char_num = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    old_i = i;</span><br><span class="line">    i = char_num;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 下</span></span><br><span class="line">    modify = <span class="number">1</span>;</span><br><span class="line">    read_history(buf, <span class="number">0</span>);</span><br><span class="line">    old_cn = char_num;</span><br><span class="line">    char_num = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    old_i = i;</span><br><span class="line">    i = char_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现名称中-b的省略"><a href="#实现名称中-b的省略" class="headerlink" title="实现名称中.b的省略"></a>实现名称中<code>.b</code>的省略</h3><p>简单对我们的命令进行语法分析可知，一条命令的结构是<code>[命令名][空格][参数*]</code>，而在我们的<code>shell</code>中的对<strong>外部命令</strong>的处理逻辑(当然，也只有外部命令需要做.b的省略)是把parse出的第一个token作为可执行文件名传入<code>spawn</code>函数，来让这个可执行文件接收参数运行起来，所以我们可以在<code>spawn</code>函数里对传入的<strong>文件名参数</strong>做手脚。</p>
<p>该功能实现相对简单，只需要修改<code>spawn</code>函数中的应用程序文件打开逻辑即可，基本逻辑的伪代码如下：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 给定文件路径为 char *path</span><br><span class="line">tryOpen(path);</span><br><span class="line">if(fail) &#123;</span><br><span class="line">    if(path is not end with &quot;.b&quot;)&#123;</span><br><span class="line">        path = path + &quot;.b&quot;;</span><br><span class="line">        tryOpen(path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体在<code>spawn.c</code>中添加c代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 显然没找到，检测是否以.b结尾</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(prog);</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span> || prog[len<span class="number">-1</span>] != <span class="string">&#x27;b&#x27;</span> || prog[len<span class="number">-2</span>] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="type">char</span> tmp_prog[MAXPATHLEN];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp_prog, prog);</span><br><span class="line">        tmp_prog[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        tmp_prog[len + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        tmp_prog[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(tmp_prog, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现mkdir、touch以及tree"><a href="#实现mkdir、touch以及tree" class="headerlink" title="实现mkdir、touch以及tree"></a>实现<code>mkdir</code>、<code>touch</code>以及<code>tree</code></h3><h4 id="创建类指令"><a href="#创建类指令" class="headerlink" title="创建类指令"></a>创建类指令</h4><p>说白了就是实现<strong>文件和目录的创建</strong>。</p>
<p>在文件系统中增加如下<code>creat</code>函数，为实现touch和mkdir做好基础性工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span>; <span class="comment">// /fs/serv.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> type)</span>; <span class="comment">// /user/lib/fsipc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> type)</span>; <span class="comment">// /user/lib/file.c</span></span><br></pre></td></tr></table></figure>

<p>对于这两个命令，我选择以<strong>外部命令</strong>的形式进行实现，也就是烧录<code>touch.b</code>和<code>mkdir.b</code>两个可执行文件到mos的根目录下，我们对<code>/user/include.mk</code>添加如下内容：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USERAPPS     := </span><br><span class="line">            ...</span><br><span class="line">            mkdir.b\</span><br><span class="line">            touch.b\</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>而烧录前的两个<code>.c</code>文件则基于增量开发的<code>create</code>函数编写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// touch.c</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: touch [filename]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the file:%s exists\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        close(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span>(create(argv[<span class="number">1</span>], FTYPE_REG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;creat file:%s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: touch [dirname]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the dir:%s exists\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        close(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span>(create(argv[<span class="number">1</span>], FTYPE_DIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;creat dir:%s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将这两个文件烧录进我们的mos系统即可实现<code>mkdir</code>和<code>touch</code>命令。</p>
<h4 id="tree的实现"><a href="#tree的实现" class="headerlink" title="tree的实现"></a><code>tree</code>的实现</h4><p><code>tree</code>这个指令，形象点说，就是个dfs版本的ls。我在实现的时候编写了一个<code>void printTree(int depth, char *path);</code>函数，具体逻辑就是给定一个目录文件的路径，以及当前对文件树的遍历深度，该函数打开该目录文件，对于类型为<code>FTYPE_REG</code>即普通文件，直接输出其名称信息，对于目录文件，输出名称信息后将当前<code>path</code>这个路径拼接上该目录名进行下一层dfs。</p>
<p>实现逻辑相对来说还是比较好盘清楚的，就是输出的时候需要考虑一下：每一行前面的<code>Tab</code>数要和递归深度保持一致，以及，别忘了输出文件名前的”|—“(四字符宽度，保证和一个<code>Tab</code>对齐)。</p>
<h4 id="重定向时对路径不存在文件的默认创建"><a href="#重定向时对路径不存在文件的默认创建" class="headerlink" title="重定向时对路径不存在文件的默认创建"></a>重定向时对路径不存在文件的默认创建</h4><p>在<code>parsecmd()</code>函数中对于’&gt;’和’&lt;’两个重定向分支的**文件打开逻辑**进行修改，以’&gt;’为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 尝试打开</span></span><br><span class="line">	<span class="keyword">if</span>(r = create(t, FTYPE_REG) &lt; <span class="number">0</span>)&#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">		user_panic(<span class="string">&quot;&lt; create failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 创建完再打开</span></span><br><span class="line">		user_panic(<span class="string">&quot;&lt; open failed&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选做-：实现相对路径"><a href="#选做-：实现相对路径" class="headerlink" title="[选做]：实现相对路径"></a>[选做]：实现相对路径</h3><p>在linux中，我们可以使用一种较为简单的方法区别绝对路径与相对路径：</p>
<ul>
<li>以’/‘开头的路径为绝对路径</li>
<li>不以’/‘开头的路径为相对路径</li>
</ul>
<p>而相对路径的实现则是依赖于“当前工作目录”的实现的，这就需要我们思考这些问题：</p>
<ul>
<li>当前工作路径存储在哪里？</li>
<li>我们如何读取当前工作路径？</li>
<li>我们如何更改当前工作路径？</li>
</ul>
<p>我的想法是将当前工作路径放在内核态，通过系统调用进行设置与读取。</p>
<p>对处理当前工作路径的系统调用<code>syscall_pwd_op(char *path, int op)</code>定义如下操作：</p>
<ul>
<li>设置(op == 0)：将当前工作路径设置为新传入的路径</li>
<li>读取(op == 1)： 返回内核中保存的当前工作路径。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对系统调用进行简单的测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall_pwd_op(<span class="string">&quot;/love/you&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> curpath[MAXPATHLEN];</span><br><span class="line">    syscall_pwd_op(curpath, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, curpath);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 `/love/you`</span></span><br></pre></td></tr></table></figure>

<p>实现这一系统调用后，理论上我们就可以支持相对路径了，但是为了用户使用方便，我在<code>/user/lib/pwb_funcs.c</code>里面封装了如下函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">move_to</span><span class="params">(<span class="type">char</span> *path)</span>; <span class="comment">// 用于进行路径移动的函数，支持传入相对路径，绝对路径以及..(回到上级目录)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_pwd</span><span class="params">(<span class="type">char</span> *pwd)</span>; <span class="comment">// 用于获取当前路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pwd</span><span class="params">()</span>; <span class="comment">// 在shell启动时初始化当前工作路径为根目录&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来就是shell的内部指令cd和pwd了，由于是内部命令，无需我们以外部可执行文件烧录的形式进行编写，只需要在<code>runcmd()</code>函数中略施小计即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;cd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    move_to(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;pwd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> tmp[MAXPATHLEN];</span><br><span class="line">    get_pwd(tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tmp);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们目前的MOS中，需要传入文件路径参数的命令文件有：<code>cat.c</code>，<code>ls.c</code>，<code>mkdir.c</code>，<code>touch.c</code>以及<code>tree.c</code>，我们需要使用上述增量内容对这些文件进行修改，以使它们可以支持相对路径。</p>
<p>我们对<code>file.c</code>中，需要传入路径参数的三个函数<code>open()</code>，<code>remove()</code>，<code>create()</code>进行修改。</p>
<p>只需要添加如下路径调整函数再在上述三个操作函数开头调用该函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adjust_path</span><span class="params">(<span class="type">char</span> *dst, <span class="type">char</span> *src)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(src[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// 传入绝对路径</span></span><br><span class="line">        <span class="built_in">strcpy</span>(dst, src);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    get_pwd(dst); <span class="comment">// 传入相对路径</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">strlen</span>(dst);</span><br><span class="line">    dst[i] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; src[j] != <span class="number">0</span>; j++)&#123;</span><br><span class="line">        dst[i+<span class="number">1</span>+j] = src[j];</span><br><span class="line">    &#125;</span><br><span class="line">    dst[i+<span class="number">1</span>+j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改完之后支持<code>cat.c</code>，<code>ls.c</code>以及<code>touch.c</code>了，接下来我们处理<code>ls.c</code>和<code>tree.c</code>。</p>
<p><code>ls</code>命令比较好对付，<code>lab6</code>初始代码的ls在没有传入命令参数时，都是默认列出根目录的信息的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ls.c -&gt; main func</span></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">0</span>) &#123; <span class="comment">// 默认情况</span></span><br><span class="line">    ls(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在实现相对路径后，应当列出当前工作路径的所有文件，故修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc == <span class="number">0</span>) &#123; <span class="comment">// 默认情况</span></span><br><span class="line">    <span class="type">char</span> tmp[MAXPATHLEN];</span><br><span class="line">    get_pwd(tmp); <span class="comment">// 取得当前工作路径</span></span><br><span class="line">    ls(tmp, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以让我们使用ls来列出当前工作目录的所有文件/目录了</p>
<p><code>tree</code>同样，原本我们编写的<code>tree.c</code>文件默认是从<code>/</code>也就是根目录开始搜，更改成从当前工作路径开始搜就好。</p>
<p>至此，我们的挑战性任务的实现就算告一段落了。在完成上述任务的基础上，我还对我的shell做了一定的美化，不过这就是题外话了，在本报告中不过多赘述。</p>
<h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="一行多命令："><a href="#一行多命令：" class="headerlink" title="一行多命令："></a>一行多命令：</h3><p>运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> string1; <span class="built_in">echo</span> string2; <span class="built_in">echo</span> string3</span><br></pre></td></tr></table></figure>

<p>得到输出：</p>
<p><img src=";.png" alt="多命令"></p>
<h3 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h3><p>编写如下测试代码并烧录进MOS：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_and.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(p--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;now test program is running!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行命令：<code>test_and &amp; ls</code></p>
<p>运行结果：</p>
<p><img src="%E5%90%8E%E5%8F%B01.png" alt="后台1"></p>
<p>接着，先输入<code>test_and &amp;</code>再输入<code>ls</code>，测试运行过程中，是否可以继续输入，以下是运行效果：</p>
<p><img src="%E5%90%8E%E5%8F%B02.png" alt="后台2"></p>
<h3 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h3><p>键入命令<code>echo &quot;mkdir abc; touch abc/hahah&quot;</code>，运行结果如下：</p>
<p><img src="%E5%BC%95%E5%8F%B7.png" alt="引号支持"></p>
<h3 id="b省略"><a href="#b省略" class="headerlink" title=".b省略"></a>.b省略</h3><p>其实上一张图已经可以看出对.b省略进行实现了。</p>
<h3 id="tree、mkdir以及touch"><a href="#tree、mkdir以及touch" class="headerlink" title="tree、mkdir以及touch"></a>tree、mkdir以及touch</h3><p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1; <span class="built_in">mkdir</span> dir2; <span class="built_in">touch</span> dir1/file1; <span class="built_in">touch</span> dir1/file2; <span class="built_in">mkdir</span> dir2/dir3; tree</span><br></pre></td></tr></table></figure>

<p>得到运行结果：</p>
<p><img src="%E6%9B%B4%E5%A4%9A%E5%91%BD%E4%BB%A4.png" alt="更多命令"></p>
<p>对于重定向自动创建文件进行测试，执行命令<code>echo &quot;adsbadabsjhdvajbdjasbdhjasbdh&quot; &gt;  a_random_file</code>后进行<code>ls; cat a_random_file</code>，得到运行结果：</p>
<p><img src="%E8%87%AA%E5%8A%A8.png" alt="自动创建"></p>
<h3 id="相对路径的实现"><a href="#相对路径的实现" class="headerlink" title="相对路径的实现"></a>相对路径的实现</h3><p>运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1; <span class="built_in">cd</span> dir1; <span class="built_in">mkdir</span> dir2; <span class="built_in">cd</span> dir2; <span class="built_in">mkdir</span> dir3; <span class="built_in">touch</span> file1; <span class="built_in">touch</span> file2; <span class="built_in">touch</span> file3; tree /dir1; <span class="built_in">pwd</span>; <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>以下是运行结果：</p>
<p><img src="%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.png" alt="相对路径"></p>
<p>在此基础上运行<code>cd ..; pwd</code>，有如下结果：</p>
<p><img src="2.png" alt="相对路径1"></p>
<p>至此，测试部分结束。</p>
<h2 id="问题-amp-解决方案"><a href="#问题-amp-解决方案" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h2><h3 id="在实现-amp-后台命令时遇到的卡顿问题"><a href="#在实现-amp-后台命令时遇到的卡顿问题" class="headerlink" title="在实现&amp;后台命令时遇到的卡顿问题"></a>在实现<code>&amp;</code>后台命令时遇到的卡顿问题</h3><p>实现完之后发现在后台命令运行过程中，若后台命令任务量较大，会出现明显的间断执行的现象，经过分析得知是<code>mos</code>中从控制台读取字符的系统调用<code>sys_cgetc()</code>的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">XXX:</span> kernel does busy waiting here, blocking all envs</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述系统调用函数存在忙等现象，我们要解决上述问题，就需要破除这种忙等现象，以下是修改(删除了造成忙等的死循环)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch = scancharc();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以这么做，是因为用户态下，<code>console.c</code>中的<code>cons_read()</code>函数已经有了如下实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((c = syscall_cgetc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    syscall_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现历史命令查询功能时遇到的保存bug"><a href="#实现历史命令查询功能时遇到的保存bug" class="headerlink" title="实现历史命令查询功能时遇到的保存bug"></a>实现历史命令查询功能时遇到的保存bug</h3><p>在实现<code>save_history()</code>函数的时候出了一点小问题，我没有考虑到每次<code>open</code>我们的<code>.history</code>文件时都会对文件描述符中的<code>fd_offset</code>字段进行重置（为0），就导致了我的实现只能保存上一次执行的命令，最终我在<code>user/lib/history.c</code>加入了全局变量<code>last_off</code>，让它记录上一次调用<code>save_history()</code>后的<code>fd_offset</code>的值，并在在下一次写入完成后维护它。</p>
<p>在上传这篇博客的时候头好痛，蹦不出几句好词儿，那就俗点：</p>
<p><strong>谨以此文献给我这2023春季学期为ooos流汗流泪的青春吧。</strong></p>
<p><img src="timeline.png" alt="timeline"></p>
<script src="https://utteranc.es/client.js"
        repo="B1fang/B1fang.github.io"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://b1fang.github.io">B1fang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://b1fang.github.io/2023/06/16/OS-Challenge/">https://b1fang.github.io/2023/06/16/OS-Challenge/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://b1fang.github.io" target="_blank">B1fang的闲人屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/bash/">bash</a><a class="post-meta__tags" href="/tags/Operating-System/">Operating System</a><a class="post-meta__tags" href="/tags/shell/">shell</a></div><div class="post_share"><div class="social-share" data-image="/images/covers/cover3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/05/28/OS-Lab6/"><img class="next-cover" src="/images/covers/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAAOS-Lab6实验报告</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/02/OS-Lab0/" title="BUAAOS-Lab0 实验报告"><img class="cover" src="/images/covers/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-02</div><div class="title">BUAAOS-Lab0 实验报告</div></div></a></div><div><a href="/2023/05/28/OS-Lab6/" title="BUAAOS-Lab6实验报告"><img class="cover" src="/images/covers/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-28</div><div class="title">BUAAOS-Lab6实验报告</div></div></a></div><div><a href="/2023/04/11/OS-Lab1/" title="BUAAOS-Lab1 实验报告"><img class="cover" src="/images/covers/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">BUAAOS-Lab1 实验报告</div></div></a></div><div><a href="/2023/04/11/OS-Lab2/" title="BUAAOS-Lab2 实验报告"><img class="cover" src="/images/covers/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">BUAAOS-Lab2 实验报告</div></div></a></div><div><a href="/2023/04/11/OS-Lab3/" title="BUAAOS-Lab3 实验报告"><img class="cover" src="/images/covers/cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">BUAAOS-Lab3 实验报告</div></div></a></div><div><a href="/2023/05/23/OS-Lab5/" title="BUAAOS-Lab05实验报告"><img class="cover" src="/images/covers/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-23</div><div class="title">BUAAOS-Lab05实验报告</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/heads/head1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">B1fang</div><div class="author-info__description">一个什么东西都有可能发的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/B1fang"><i class="fab fa-github"></i><span>快点点进来罢（喜）</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/B1fang" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wuzebro@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">恭喜俺嘞博客终于搭建完成！！！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E7%9C%8B%E6%88%91%E7%9A%84Shell%EF%BC%81"><span class="toc-number">1.</span> <span class="toc-text">看看我的Shell！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">实现记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%94%B1-%E5%88%86%E9%9A%94%E7%9A%84%E4%B8%80%E8%A1%8C%E5%A4%9A%E5%91%BD%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">实现由;分隔的一行多命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-amp-%E5%90%8E%E7%BC%80%E7%9A%84shell%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.2.</span> <span class="toc-text">实现&amp;后缀的shell后台任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%95%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">2.3.</span> <span class="toc-text">实现引号包裹的字符串的支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%94%AE%E5%85%A5%E5%91%BD%E4%BB%A4%E6%97%B6%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%BF%AE%E6%94%B9-amp-%E5%AE%9E%E7%8E%B0%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">实现键入命令时任意位置的修改 &amp; 实现历史命令功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9readline%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">对readline函数的逻辑进行重构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%85%89%E6%A0%87%E5%B7%A6%E5%8F%B3%E7%A7%BB%E5%8A%A8%E8%BF%9B%E8%A1%8C%E7%9B%B8%E5%BA%94%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">支持光标左右移动进行相应位置的插入与删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E4%B8%8A%E4%B8%8B%E9%94%AE%E5%AF%B9%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.4.3.</span> <span class="toc-text">支持上下键对历史记录的查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%90%8D%E7%A7%B0%E4%B8%AD-b%E7%9A%84%E7%9C%81%E7%95%A5"><span class="toc-number">2.5.</span> <span class="toc-text">实现名称中.b的省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0mkdir%E3%80%81touch%E4%BB%A5%E5%8F%8Atree"><span class="toc-number">2.6.</span> <span class="toc-text">实现mkdir、touch以及tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.1.</span> <span class="toc-text">创建类指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tree%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">tree的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%97%B6%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8D%E5%AD%98%E5%9C%A8%E6%96%87%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA"><span class="toc-number">2.6.3.</span> <span class="toc-text">重定向时对路径不存在文件的默认创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E5%81%9A-%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.7.</span> <span class="toc-text">[选做]：实现相对路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">功能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%A1%8C%E5%A4%9A%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">一行多命令：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">实现后台任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%95%E5%8F%B7%E6%94%AF%E6%8C%81"><span class="toc-number">3.3.</span> <span class="toc-text">实现引号支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b%E7%9C%81%E7%95%A5"><span class="toc-number">3.4.</span> <span class="toc-text">.b省略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tree%E3%80%81mkdir%E4%BB%A5%E5%8F%8Atouch"><span class="toc-number">3.5.</span> <span class="toc-text">tree、mkdir以及touch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.</span> <span class="toc-text">相对路径的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98-amp-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.</span> <span class="toc-text">问题&amp;解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E7%8E%B0-amp-%E5%90%8E%E5%8F%B0%E5%91%BD%E4%BB%A4%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%8D%A1%E9%A1%BF%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">在实现&amp;后台命令时遇到的卡顿问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%BF%9D%E5%AD%98bug"><span class="toc-number">4.2.</span> <span class="toc-text">实现历史命令查询功能时遇到的保存bug</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/OS-Challenge/" title="BUAAOS-Lab6 Challenge"><img src="/images/covers/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAAOS-Lab6 Challenge"/></a><div class="content"><a class="title" href="/2023/06/16/OS-Challenge/" title="BUAAOS-Lab6 Challenge">BUAAOS-Lab6 Challenge</a><time datetime="2023-06-16T15:20:44.000Z" title="发表于 2023-06-16 23:20:44">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/28/OS-Lab6/" title="BUAAOS-Lab6实验报告"><img src="/images/covers/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAAOS-Lab6实验报告"/></a><div class="content"><a class="title" href="/2023/05/28/OS-Lab6/" title="BUAAOS-Lab6实验报告">BUAAOS-Lab6实验报告</a><time datetime="2023-05-28T12:09:44.000Z" title="发表于 2023-05-28 20:09:44">2023-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/23/OS-Lab5/" title="BUAAOS-Lab05实验报告"><img src="/images/covers/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAAOS-Lab05实验报告"/></a><div class="content"><a class="title" href="/2023/05/23/OS-Lab5/" title="BUAAOS-Lab05实验报告">BUAAOS-Lab05实验报告</a><time datetime="2023-05-23T03:25:44.000Z" title="发表于 2023-05-23 11:25:44">2023-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/OS-Lab4/" title="BUAAOS-Lab4 实验报告"><img src="/images/covers/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAAOS-Lab4 实验报告"/></a><div class="content"><a class="title" href="/2023/05/07/OS-Lab4/" title="BUAAOS-Lab4 实验报告">BUAAOS-Lab4 实验报告</a><time datetime="2023-05-07T09:46:44.000Z" title="发表于 2023-05-07 17:46:44">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/11/OS-Lab1/" title="BUAAOS-Lab1 实验报告"><img src="/images/covers/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAAOS-Lab1 实验报告"/></a><div class="content"><a class="title" href="/2023/04/11/OS-Lab1/" title="BUAAOS-Lab1 实验报告">BUAAOS-Lab1 实验报告</a><time datetime="2023-04-11T10:51:44.000Z" title="发表于 2023-04-11 18:51:44">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By B1fang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>