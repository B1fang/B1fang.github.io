<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAAOS-Lab6 Challenge</title>
      <link href="/2023/06/16/OS-Challenge/"/>
      <url>/2023/06/16/OS-Challenge/</url>
      
        <content type="html"><![CDATA[<h2 id="看看我的Shell！"><a href="#看看我的Shell！" class="headerlink" title="看看我的Shell！"></a>看看我的Shell！</h2><p><img src="shell.jpg" alt="shell"></p><h2 id="实现记录"><a href="#实现记录" class="headerlink" title="实现记录"></a>实现记录</h2><p>由于我选择的是Lab6的挑战性任务，整体的子任务数较多，本人能力所限无法用一条完整的思路串联起所有的子任务，故为该节起名为：<strong>记录</strong>，还请看官海涵。这一部分基本按照<code>osome</code>平台上的任务顺序组织（虽然与实际实现历程有一定差异，我为了更方便对这些拓展功能进行测试，实际上先完成了对命令编辑功能的优化）。</p><h3 id="实现由-分隔的一行多命令"><a href="#实现由-分隔的一行多命令" class="headerlink" title="实现由;分隔的一行多命令"></a>实现由<code>;</code>分隔的一行多命令</h3><p>由于分号已经在<code>sh.c</code>中以宏定义的形式被加入到<strong>保留符号</strong>了，故只需要修改<code>parsecmd()</code>函数使其增添对于<code>&#39;;&#39;</code>这一符号的处理能力即可。</p><p>本功能的具体思路就是当解析遇到一个’;’符号后，<code>fork</code>一个子shell，让子shell继续执行左边的命令，父shell等待子shell执行完成后，执行’;’符号右边的命令，具体的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:;</span><br><span class="line"><span class="type">int</span> child = fork(); <span class="comment">// fork出两个进程</span></span><br><span class="line"><span class="keyword">if</span>(child) &#123; <span class="comment">// 父进程等待子进程执行完再执行&#x27;;&#x27;右边的命令</span></span><br><span class="line"><span class="keyword">if</span>(re_alloc == <span class="number">0</span>)&#123; <span class="comment">// 如果前一条命令出现了重定向，那么再重定向回来</span></span><br><span class="line">dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(re_alloc == <span class="number">1</span>) &#123;</span><br><span class="line">dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        wait(child);</span><br><span class="line"><span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程执行&#x27;;&#x27;左边的命令</span></span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="实现-amp-后缀的shell后台任务"><a href="#实现-amp-后缀的shell后台任务" class="headerlink" title="实现&amp;后缀的shell后台任务"></a>实现<code>&amp;</code>后缀的shell后台任务</h3><p>其实本功能和上一项的实现较为类似，只是增加了一点要求：我们的shell只需要等待’&amp;’右侧的命令的执行完毕，而左侧的命令处于“<strong>后台运行</strong>”状态，shell进程无需等待。与对’;’的处理相似，我们对<code>parsecmd()</code>做如下修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe, <span class="type">int</span> *_wait)</span>&#123; <span class="comment">// 为函数头添加 int *_wait参数，用于指示当前执行的程序是否需要cmd进行等待</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:;</span><br><span class="line">        <span class="type">int</span> child_ = fork();</span><br><span class="line">        <span class="keyword">if</span>(child_) &#123; <span class="comment">// 父进程执行右边的命令</span></span><br><span class="line">            <span class="keyword">if</span>(re_alloc == <span class="number">0</span>)&#123; <span class="comment">// 如果前一条命令出现了重定向，那么再重定向回来</span></span><br><span class="line">dup(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(re_alloc == <span class="number">1</span>) &#123;</span><br><span class="line">dup(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">            *_wait = <span class="number">1</span>; <span class="comment">// 需要shell等待</span></span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe, _wait);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程执行左边的命令</span></span><br><span class="line">            *_wait = <span class="number">0</span>; <span class="comment">// 不需要shell等待</span></span><br><span class="line">            <span class="keyword">return</span> argc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到与’;’的实现不同点在于父子进程没有通过调用<code>wait()</code>函数进行互相的等待，这是因为后台指令理论上是与前台指令并发的，同时，我们新增了<code>_wait</code>这个<code>int</code>型的指针，它的用法是在<code>runcmd()</code>中告知程序是否需要对当前执行程序进行等待，我们对<code>runcmd()</code>函数的具体修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _wait = <span class="number">1</span>; <span class="comment">// 默认是需要等待的</span></span><br><span class="line"><span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br><span class="line">close_all();</span><br><span class="line"><span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(_wait)&#123;</span><br><span class="line">        wait(child); <span class="comment">// 在需要等待时等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这只是在cmd层面实现了该指令，但是我们的<code>mos</code>内核存在一些小问题影响了该功能的运行效果，该问题的解决我们放在最后一部分<strong>问题&amp;解决方案</strong>来讲。</p><h3 id="实现引号包裹的字符串的支持"><a href="#实现引号包裹的字符串的支持" class="headerlink" title="实现引号包裹的字符串的支持"></a>实现引号包裹的字符串的支持</h3><p>对引号的支持可以在<strong>词法解析</strong>时实现，其本质就是在词法解析时将两个引号间的字符串<strong>看作一个词法单元</strong>，具体实现我们可以在<code>_gettoken()</code>函数中增加如下部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123; <span class="comment">// 识别引号</span></span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line">    s++;</span><br><span class="line">    *p1 = s;</span><br><span class="line">    <span class="keyword">while</span>(*s &amp;&amp; (*s != <span class="string">&#x27;\&quot;&#x27;</span>))&#123;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">    *s++ = <span class="number">0</span>;</span><br><span class="line">    *p2 = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;s&#x27;</span>; <span class="comment">// it means &quot;string&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改<code>_gettoken()</code>函数时遇到了一点小bug，我第一次写的时候没有将字符串末尾引号置为’\0’，导致实际运行过程中会将前引号之后的所有内容都视为一个字符串，修改后就没问题了。</p><p>并在<code>parsecmd()</code>函数中增加针对于字符串此法单元的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= MAXARGS) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;too many arguments\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc++] = t;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="实现键入命令时任意位置的修改-amp-实现历史命令功能"><a href="#实现键入命令时任意位置的修改-amp-实现历史命令功能" class="headerlink" title="实现键入命令时任意位置的修改 &amp; 实现历史命令功能"></a>实现键入命令时任意位置的修改 &amp; 实现历史命令功能</h3><p><strong>这真的是我做的最痛苦的一块了</strong>，<del>真的是在bug里面找代码</del>。由于均牵涉到方向键的处理，所以我把这两个任务放在一起了。</p><p>首先，查阅资料可知，<strong>上下左右</strong>键在linux中的编码为：</p><table><thead><tr><th align="center">键</th><th align="center">编码</th></tr></thead><tbody><tr><td align="center">上</td><td align="center">27 ‘[‘ ‘A’</td></tr><tr><td align="center">下</td><td align="center">27 ‘[‘ ‘B’</td></tr><tr><td align="center">左</td><td align="center">27 ‘[‘ ‘D’</td></tr><tr><td align="center">右</td><td align="center">27 ‘[‘ ‘C’</td></tr></tbody></table><p>也就是说，当我们在linux系统下，在键盘下按下一个方向键，就拿’↑’举例子吧，就会往缓冲区顺序写入三个字符，分别是<code>ascii[27]</code>，’[‘以及’A’。</p><p>基于上述理解，我们对shell的命令编辑体验进行优化。</p><h4 id="对readline函数的逻辑进行重构"><a href="#对readline函数的逻辑进行重构" class="headerlink" title="对readline函数的逻辑进行重构"></a>对readline函数的逻辑进行重构</h4><p>首先，我们将从stdin读入进来的字符分为五类：</p><ul><li>上下方向键(具体编码见上)</li><li>左右方向键(具体编码见上)</li><li>退格键(‘\b’)</li><li>回车键(‘\n’ || ‘\r’)</li><li>可见ascii码(其它情况)</li></ul><p>对于我们的buf数组，我们需要一个标定其下一次插入位置的整形变量<code>i</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;<span class="comment">// 指示当前编辑位置的指针变量</span></span><br><span class="line">    buf[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> char_num = <span class="number">0</span>; <span class="comment">// 当前插入的字符数</span></span><br><span class="line">    <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(char_num &lt;= n) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;tmp, <span class="number">1</span>); <span class="comment">// 从缓冲区中读入下一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&#x27;\n&#x27;</span> || tmp == <span class="string">&#x27;\r&#x27;</span>) &#123; <span class="comment">// 读入了换行符则直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="number">27</span>) &#123;</span><br><span class="line">            <span class="comment">// 方向键逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(buf[i] == <span class="string">&#x27;\b&#x27;</span> || buf[i] == <span class="number">0x7f</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在插入位置插入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    debugf(<span class="string">&quot;line too long\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ((r = read(<span class="number">0</span>, buf, <span class="number">1</span>)) == <span class="number">1</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 读空缓冲区，忽略已输入内容</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="支持光标左右移动进行相应位置的插入与删除"><a href="#支持光标左右移动进行相应位置的插入与删除" class="headerlink" title="支持光标左右移动进行相应位置的插入与删除"></a>支持光标左右移动进行相应位置的插入与删除</h4><p>首先是<code>buf</code>层面的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp == <span class="string">&#x27;D&#x27;</span>) &#123; <span class="comment">// 左</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c[C&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">&#x27;C&#x27;</span>) &#123; <span class="comment">// 右</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="built_in">strlen</span>(buf)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c[D&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="comment">// 如果已经指向末尾，不必移动</span></span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是回显逻辑就相对来说比较麻烦，我们应当针对左、右、删、插操作设置相应的回显。</p><p>其实左键和右键并不需要处理，光标单纯的左右移动并不需要我们来操心，我们只需要关心进行删除和插入的时候如何进行回显。</p><p>最终我采取了这样每次插入和删除操作后都进行刷新的做法，<del>虽然效率比较低而且频闪比较高</del>，总结下来主要有以下几步：</p><ul><li>移动光标到被编辑指令的末尾</li><li>输出<strong>足够的</strong>“\b \b”删除旧命令</li><li>输出新命令</li><li>维护光标到编辑位置</li></ul><p>具体代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(modify) &#123; <span class="comment">// 如果发生了删改</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = old_i; x &lt; old_cn; x++)&#123; <span class="comment">// 移动光标到最后</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; old_cn; x++)&#123; <span class="comment">// 清除本行内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\b \b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf); <span class="comment">// 输出新内容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = i; x &lt; char_num; x++)&#123; <span class="comment">// 维护光标位置</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[D&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>鬼知道这个回显我调了多少次</del>。</p><h4 id="支持上下键对历史记录的查询"><a href="#支持上下键对历史记录的查询" class="headerlink" title="支持上下键对历史记录的查询"></a>支持上下键对历史记录的查询</h4><p>对于打好<code>readline()</code>框架和已经实现文件创建接口的我们来说并不是一件困难的事情。</p><p>为了对我们在根目录下保存历史记录的<code>.history</code>文件进行初始化以及读写操作，我们在用户库的<code>history.c</code>文件里编写了如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_history</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_history</span><span class="params">(<span class="type">char</span> *cmd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_history</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> direction)</span>; <span class="comment">// direction == 1时上移，direction == 0时下移</span></span><br></pre></td></tr></table></figure><p>并在根目录下编写了<code>history.c</code>文件以烧录进MOS中以实现列出所有历史命令的<code>history</code>命令。</p><p>最后的要做的就是在我们的<code>readline()</code>函数里面写好调用逻辑就好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tmp == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">// 上</span></span><br><span class="line">    modify = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c[B&quot;</span>, <span class="number">27</span>); <span class="comment">// 不许乱动</span></span><br><span class="line">    read_history(buf, <span class="number">1</span>); <span class="comment">// 读取历史命令</span></span><br><span class="line">    old_cn = char_num; <span class="comment">// 维护这些状态变量</span></span><br><span class="line">    char_num = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    old_i = i;</span><br><span class="line">    i = char_num;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 下</span></span><br><span class="line">    modify = <span class="number">1</span>;</span><br><span class="line">    read_history(buf, <span class="number">0</span>);</span><br><span class="line">    old_cn = char_num;</span><br><span class="line">    char_num = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    old_i = i;</span><br><span class="line">    i = char_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现名称中-b的省略"><a href="#实现名称中-b的省略" class="headerlink" title="实现名称中.b的省略"></a>实现名称中<code>.b</code>的省略</h3><p>简单对我们的命令进行语法分析可知，一条命令的结构是<code>[命令名][空格][参数*]</code>，而在我们的<code>shell</code>中的对<strong>外部命令</strong>的处理逻辑(当然，也只有外部命令需要做.b的省略)是把parse出的第一个token作为可执行文件名传入<code>spawn</code>函数，来让这个可执行文件接收参数运行起来，所以我们可以在<code>spawn</code>函数里对传入的<strong>文件名参数</strong>做手脚。</p><p>该功能实现相对简单，只需要修改<code>spawn</code>函数中的应用程序文件打开逻辑即可，基本逻辑的伪代码如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 给定文件路径为 char *path</span><br><span class="line">tryOpen(path);</span><br><span class="line">if(fail) &#123;</span><br><span class="line">    if(path is not end with &quot;.b&quot;)&#123;</span><br><span class="line">        path = path + &quot;.b&quot;;</span><br><span class="line">        tryOpen(path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体在<code>spawn.c</code>中添加c代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 显然没找到，检测是否以.b结尾</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(prog);</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span> || prog[len<span class="number">-1</span>] != <span class="string">&#x27;b&#x27;</span> || prog[len<span class="number">-2</span>] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="type">char</span> tmp_prog[MAXPATHLEN];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp_prog, prog);</span><br><span class="line">        tmp_prog[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        tmp_prog[len + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        tmp_prog[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>((fd = open(tmp_prog, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现mkdir、touch以及tree"><a href="#实现mkdir、touch以及tree" class="headerlink" title="实现mkdir、touch以及tree"></a>实现<code>mkdir</code>、<code>touch</code>以及<code>tree</code></h3><h4 id="创建类指令"><a href="#创建类指令" class="headerlink" title="创建类指令"></a>创建类指令</h4><p>说白了就是实现<strong>文件和目录的创建</strong>。</p><p>在文件系统中增加如下<code>creat</code>函数，为实现touch和mkdir做好基础性工作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span>; <span class="comment">// /fs/serv.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> type)</span>; <span class="comment">// /user/lib/fsipc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">int</span> type)</span>; <span class="comment">// /user/lib/file.c</span></span><br></pre></td></tr></table></figure><p>对于这两个命令，我选择以<strong>外部命令</strong>的形式进行实现，也就是烧录<code>touch.b</code>和<code>mkdir.b</code>两个可执行文件到mos的根目录下，我们对<code>/user/include.mk</code>添加如下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">USERAPPS     := </span><br><span class="line">            ...</span><br><span class="line">            mkdir.b\</span><br><span class="line">            touch.b\</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>而烧录前的两个<code>.c</code>文件则基于增量开发的<code>create</code>函数编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// touch.c</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: touch [filename]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the file:%s exists\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        close(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span>(create(argv[<span class="number">1</span>], FTYPE_REG) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;creat file:%s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: touch [dirname]\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = open(argv[<span class="number">1</span>], O_RDONLY); <span class="comment">// 创建文件</span></span><br><span class="line">    <span class="keyword">if</span>(r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the dir:%s exists\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        close(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span>(create(argv[<span class="number">1</span>], FTYPE_DIR) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;creat dir:%s failed\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这两个文件烧录进我们的mos系统即可实现<code>mkdir</code>和<code>touch</code>命令。</p><h4 id="tree的实现"><a href="#tree的实现" class="headerlink" title="tree的实现"></a><code>tree</code>的实现</h4><p><code>tree</code>这个指令，形象点说，就是个dfs版本的ls。我在实现的时候编写了一个<code>void printTree(int depth, char *path);</code>函数，具体逻辑就是给定一个目录文件的路径，以及当前对文件树的遍历深度，该函数打开该目录文件，对于类型为<code>FTYPE_REG</code>即普通文件，直接输出其名称信息，对于目录文件，输出名称信息后将当前<code>path</code>这个路径拼接上该目录名进行下一层dfs。</p><p>实现逻辑相对来说还是比较好盘清楚的，就是输出的时候需要考虑一下：每一行前面的<code>Tab</code>数要和递归深度保持一致，以及，别忘了输出文件名前的”|—“(四字符宽度，保证和一个<code>Tab</code>对齐)。</p><h4 id="重定向时对路径不存在文件的默认创建"><a href="#重定向时对路径不存在文件的默认创建" class="headerlink" title="重定向时对路径不存在文件的默认创建"></a>重定向时对路径不存在文件的默认创建</h4><p>在<code>parsecmd()</code>函数中对于’&gt;’和’&lt;’两个重定向分支的**文件打开逻辑**进行修改，以’&gt;’为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>)&#123; <span class="comment">// 尝试打开</span></span><br><span class="line"><span class="keyword">if</span>(r = create(t, FTYPE_REG) &lt; <span class="number">0</span>)&#123; <span class="comment">// 不存在则创建</span></span><br><span class="line">user_panic(<span class="string">&quot;&lt; create failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="comment">// 创建完再打开</span></span><br><span class="line">user_panic(<span class="string">&quot;&lt; open failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选做-：实现相对路径"><a href="#选做-：实现相对路径" class="headerlink" title="[选做]：实现相对路径"></a>[选做]：实现相对路径</h3><p>在linux中，我们可以使用一种较为简单的方法区别绝对路径与相对路径：</p><ul><li>以’/‘开头的路径为绝对路径</li><li>不以’/‘开头的路径为相对路径</li></ul><p>而相对路径的实现则是依赖于“当前工作目录”的实现的，这就需要我们思考这些问题：</p><ul><li>当前工作路径存储在哪里？</li><li>我们如何读取当前工作路径？</li><li>我们如何更改当前工作路径？</li></ul><p>我的想法是将当前工作路径放在内核态，通过系统调用进行设置与读取。</p><p>对处理当前工作路径的系统调用<code>syscall_pwd_op(char *path, int op)</code>定义如下操作：</p><ul><li>设置(op == 0)：将当前工作路径设置为新传入的路径</li><li>读取(op == 1)： 返回内核中保存的当前工作路径。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对系统调用进行简单的测试</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    syscall_pwd_op(<span class="string">&quot;/love/you&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> curpath[MAXPATHLEN];</span><br><span class="line">    syscall_pwd_op(curpath, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, curpath);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 `/love/you`</span></span><br></pre></td></tr></table></figure><p>实现这一系统调用后，理论上我们就可以支持相对路径了，但是为了用户使用方便，我在<code>/user/lib/pwb_funcs.c</code>里面封装了如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">move_to</span><span class="params">(<span class="type">char</span> *path)</span>; <span class="comment">// 用于进行路径移动的函数，支持传入相对路径，绝对路径以及..(回到上级目录)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_pwd</span><span class="params">(<span class="type">char</span> *pwd)</span>; <span class="comment">// 用于获取当前路径</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_pwd</span><span class="params">()</span>; <span class="comment">// 在shell启动时初始化当前工作路径为根目录&quot;/&quot;</span></span><br></pre></td></tr></table></figure><p>接下来就是shell的内部指令cd和pwd了，由于是内部命令，无需我们以外部可执行文件烧录的形式进行编写，只需要在<code>runcmd()</code>函数中略施小计即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;cd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    move_to(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;pwd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> tmp[MAXPATHLEN];</span><br><span class="line">    get_pwd(tmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, tmp);</span><br><span class="line">    <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们目前的MOS中，需要传入文件路径参数的命令文件有：<code>cat.c</code>，<code>ls.c</code>，<code>mkdir.c</code>，<code>touch.c</code>以及<code>tree.c</code>，我们需要使用上述增量内容对这些文件进行修改，以使它们可以支持相对路径。</p><p>我们对<code>file.c</code>中，需要传入路径参数的三个函数<code>open()</code>，<code>remove()</code>，<code>create()</code>进行修改。</p><p>只需要添加如下路径调整函数再在上述三个操作函数开头调用该函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adjust_path</span><span class="params">(<span class="type">char</span> *dst, <span class="type">char</span> *src)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(src[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123; <span class="comment">// 传入绝对路径</span></span><br><span class="line">        <span class="built_in">strcpy</span>(dst, src);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    get_pwd(dst); <span class="comment">// 传入相对路径</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">strlen</span>(dst);</span><br><span class="line">    dst[i] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; src[j] != <span class="number">0</span>; j++)&#123;</span><br><span class="line">        dst[i+<span class="number">1</span>+j] = src[j];</span><br><span class="line">    &#125;</span><br><span class="line">    dst[i+<span class="number">1</span>+j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完之后支持<code>cat.c</code>，<code>ls.c</code>以及<code>touch.c</code>了，接下来我们处理<code>ls.c</code>和<code>tree.c</code>。</p><p><code>ls</code>命令比较好对付，<code>lab6</code>初始代码的ls在没有传入命令参数时，都是默认列出根目录的信息的，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ls.c -&gt; main func</span></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">0</span>) &#123; <span class="comment">// 默认情况</span></span><br><span class="line">    ls(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在实现相对路径后，应当列出当前工作路径的所有文件，故修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc == <span class="number">0</span>) &#123; <span class="comment">// 默认情况</span></span><br><span class="line">    <span class="type">char</span> tmp[MAXPATHLEN];</span><br><span class="line">    get_pwd(tmp); <span class="comment">// 取得当前工作路径</span></span><br><span class="line">    ls(tmp, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以让我们使用ls来列出当前工作目录的所有文件/目录了</p><p><code>tree</code>同样，原本我们编写的<code>tree.c</code>文件默认是从<code>/</code>也就是根目录开始搜，更改成从当前工作路径开始搜就好。</p><p>至此，我们的挑战性任务的实现就算告一段落了。在完成上述任务的基础上，我还对我的shell做了一定的美化，不过这就是题外话了，在本报告中不过多赘述。</p><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h3 id="一行多命令："><a href="#一行多命令：" class="headerlink" title="一行多命令："></a>一行多命令：</h3><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> string1; <span class="built_in">echo</span> string2; <span class="built_in">echo</span> string3</span><br></pre></td></tr></table></figure><p>得到输出：</p><p><img src=";.png" alt="多命令"></p><h3 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h3><p>编写如下测试代码并烧录进MOS：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_and.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span>(p--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;now test program is running!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先执行命令：<code>test_and &amp; ls</code></p><p>运行结果：</p><p><img src="%E5%90%8E%E5%8F%B01.png" alt="后台1"></p><p>接着，先输入<code>test_and &amp;</code>再输入<code>ls</code>，测试运行过程中，是否可以继续输入，以下是运行效果：</p><p><img src="%E5%90%8E%E5%8F%B02.png" alt="后台2"></p><h3 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h3><p>键入命令<code>echo &quot;mkdir abc; touch abc/hahah&quot;</code>，运行结果如下：</p><p><img src="%E5%BC%95%E5%8F%B7.png" alt="引号支持"></p><h3 id="b省略"><a href="#b省略" class="headerlink" title=".b省略"></a>.b省略</h3><p>其实上一张图已经可以看出对.b省略进行实现了。</p><h3 id="tree、mkdir以及touch"><a href="#tree、mkdir以及touch" class="headerlink" title="tree、mkdir以及touch"></a>tree、mkdir以及touch</h3><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1; <span class="built_in">mkdir</span> dir2; <span class="built_in">touch</span> dir1/file1; <span class="built_in">touch</span> dir1/file2; <span class="built_in">mkdir</span> dir2/dir3; tree</span><br></pre></td></tr></table></figure><p>得到运行结果：</p><p><img src="%E6%9B%B4%E5%A4%9A%E5%91%BD%E4%BB%A4.png" alt="更多命令"></p><p>对于重定向自动创建文件进行测试，执行命令<code>echo &quot;adsbadabsjhdvajbdjasbdhjasbdh&quot; &gt;  a_random_file</code>后进行<code>ls; cat a_random_file</code>，得到运行结果：</p><p><img src="%E8%87%AA%E5%8A%A8.png" alt="自动创建"></p><h3 id="相对路径的实现"><a href="#相对路径的实现" class="headerlink" title="相对路径的实现"></a>相对路径的实现</h3><p>运行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> dir1; <span class="built_in">cd</span> dir1; <span class="built_in">mkdir</span> dir2; <span class="built_in">cd</span> dir2; <span class="built_in">mkdir</span> dir3; <span class="built_in">touch</span> file1; <span class="built_in">touch</span> file2; <span class="built_in">touch</span> file3; tree /dir1; <span class="built_in">pwd</span>; <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>以下是运行结果：</p><p><img src="%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.png" alt="相对路径"></p><p>在此基础上运行<code>cd ..; pwd</code>，有如下结果：</p><p><img src="2.png" alt="相对路径1"></p><p>至此，测试部分结束。</p><h2 id="问题-amp-解决方案"><a href="#问题-amp-解决方案" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h2><h3 id="在实现-amp-后台命令时遇到的卡顿问题"><a href="#在实现-amp-后台命令时遇到的卡顿问题" class="headerlink" title="在实现&amp;后台命令时遇到的卡顿问题"></a>在实现<code>&amp;</code>后台命令时遇到的卡顿问题</h3><p>实现完之后发现在后台命令运行过程中，若后台命令任务量较大，会出现明显的间断执行的现象，经过分析得知是<code>mos</code>中从控制台读取字符的系统调用<code>sys_cgetc()</code>的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">XXX:</span> kernel does busy waiting here, blocking all envs</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述系统调用函数存在忙等现象，我们要解决上述问题，就需要破除这种忙等现象，以下是修改(删除了造成忙等的死循环)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch = scancharc();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以这么做，是因为用户态下，<code>console.c</code>中的<code>cons_read()</code>函数已经有了如下实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((c = syscall_cgetc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    syscall_yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现历史命令查询功能时遇到的保存bug"><a href="#实现历史命令查询功能时遇到的保存bug" class="headerlink" title="实现历史命令查询功能时遇到的保存bug"></a>实现历史命令查询功能时遇到的保存bug</h3><p>在实现<code>save_history()</code>函数的时候出了一点小问题，我没有考虑到每次<code>open</code>我们的<code>.history</code>文件时都会对文件描述符中的<code>fd_offset</code>字段进行重置（为0），就导致了我的实现只能保存上一次执行的命令，最终我在<code>user/lib/history.c</code>加入了全局变量<code>last_off</code>，让它记录上一次调用<code>save_history()</code>后的<code>fd_offset</code>的值，并在在下一次写入完成后维护它。</p><p>在上传这篇博客的时候头好痛，蹦不出几句好词儿，那就俗点：</p><p><strong>谨以此文献给我这2023春季学期为ooos流汗流泪的青春吧。</strong></p><p><img src="timeline.png" alt="timeline"></p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> Operating System </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab6实验报告</title>
      <link href="/2023/05/28/OS-Lab6/"/>
      <url>/2023/05/28/OS-Lab6/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</p></blockquote><p>以下是修改后的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fildes[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    status = pipe(fildes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(status == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(fork())&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">// 作为写者的子进程</span></span><br><span class="line">        close(fildes[<span class="number">0</span>]);  <span class="comment">// 关闭不用的读端</span></span><br><span class="line">            write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            close(fildes[<span class="number">1</span>]); <span class="comment">// 写入结束，关闭写端</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 作为读者的父进程</span></span><br><span class="line">            close(fildes[<span class="number">1</span>]); <span class="comment">// 关闭不用的写端</span></span><br><span class="line">            read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">// 从管道中读数据</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;father-process read:%s\n&quot;</span>, buf); <span class="comment">// 打印读出的数据</span></span><br><span class="line">            close(fildes[<span class="number">0</span>]); <span class="comment">// 读取结束，关闭读端</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本地编译运行得到输出结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">father-process read:Hello world</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？</p></blockquote><p>修改前的逻辑是：先将文件描述符进行复制(map到新地址)，再将文件内容进行复制。这样就会出现<code>pageref(fd)</code>比<code>pageref(pipe)</code>先进行更新的情况，也就是调用<code>dup</code>后<code>pageref(fd)</code>会比<code>pageref(pipe)</code>先加一。</p><p>那么可能会存在这样的情况：子进程调用<code>dup</code>复制写端的文件描述符前，有<code>pageref(p[1]) == pageref(pipe) - 1</code>，而在两次map中发生进程切换，转换到父进程运行，而父进程调用了<code>pipe_is_closed(p[1])</code>，而此时的确满足<code>pageref(p[1]) == pageref(pipe)</code>，就会得出管道已经关闭的错误情况了。</p><h3 id="Thinling-6-3"><a href="#Thinling-6-3" class="headerlink" title="Thinling 6.3"></a>Thinling 6.3</h3><blockquote><p>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是<br>所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。</p></blockquote><p>首先，我认为系统调用一定<strong>是</strong>原子操作。</p><p>首先来看用户进程进行系统调用的调用链：</p><p><img src="pics/syscall.png" alt="syscall流程"></p><p>可以发现，系统调用是由<code>/user/lib/syscall_wrap.S/msyscall</code>函数中的<code>syscall</code>汇编指令触发的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LEAF(msyscall)</span><br><span class="line">// Just use &#x27;syscall&#x27; instruction and return.</span><br><span class="line">syscall</span><br><span class="line">nop</span><br><span class="line">jr ra</span><br><span class="line">nop</span><br><span class="line">END(msyscall)</span><br></pre></td></tr></table></figure><p>Lab3指导书有如下描述：</p><blockquote><p>此外，R3000 中 SR 寄存器的低六位是一个二重栈的结构。KUo 和 IEo 是一组，每当异常发生的时候，CPU 自动会将 KUp 和 IEp 的数值拷贝到这里；KUp 和 IEp 是一组，<strong>每当异常发生的时候</strong>，CPU 会把 KUc 和 IEc 的数值拷贝到这里。<strong>随后将 KUc 和 IEc 置为 0</strong>。<br>一组数值表示一种 CPU 的运行状态，其中 KU 位表示是否位于用户模式下，为 1 表示位于用户模式下；<strong>IE 位表示中断是否开启，为 1 表示开启，否则不开启</strong>，而 KUc 和 IEc 则为 <strong>CPU当前实际的运行状态</strong>。</p></blockquote><p>也就是说，我们通过<code>syscall</code>指令触发异常，陷入内核态处理系统调用时，已经通过对<code>IEc</code>置0来关闭所有中断了，也就是说，系统调用是通过“关中断”实现的原子操作。</p><p>而MIPSR3000文档的这段描述也可以佐证我们的这一论断。</p><p><img src="pics/%E6%96%87%E6%A1%A3.png" alt="文档描述"></p><h3 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h3><blockquote><p>仔细阅读上面这段话，并思考下列问题</p><ul><li>按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</li></ul></blockquote><p><strong>第一问</strong>：</p><p>可以解决，对于这样的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pipe_close</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line"><span class="comment">// Unmap &#x27;fd&#x27; and the referred Pipe.</span></span><br><span class="line">syscall_mem_unmap(<span class="number">0</span>, fd);</span><br><span class="line">syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)fd2data(fd));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难分析得出必然存在不等式<code>page_ref(fd) &lt;= page_ref(pipe)</code>，而当我们像上面这样设置unmap操作的顺序的话，在两次unmap中间对<code>pipe_close</code>进行中断的话，必然有<code>page_ref(fd) &lt; page_ref(pipe)</code>成立，因此不会在这个过程中对管道的开关过程发生误判。</p><p><strong>第二问</strong>：</p><p>会出现问题。正如我在<strong>Thinking 6.2</strong>中所写的那样，如果先对fd进行map后对page进行map的话，会诱发<code>page_ref(fd) == page_ref(pipe)</code>这样的情况，造成误判。</p><h3 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h3><blockquote><p>思考以下三个问题。</p><ul><li>认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。</li><li>回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。</li><li>在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载 ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？</li></ul></blockquote><p><strong>第一问</strong>：</p><p><code>user/lib/files.c</code>文件中的<code>open</code>函数调用同文件夹下的<code>fsipc open</code>函数,<code>fsipc open</code>通过调用<code>fsipc</code>函数向服务进程进行进程间通信，并接收返回的消息。而相应的文件系统服务进程的<code>serve_open</code>函数调用<code>file_open</code>对文件进行打开操作，最终通过进程间通信实现与用户进程对文件描述符的共享。</p><p><strong>第二问</strong>：</p><p>由<code>kern/env.c</code>文件中的<code>load_icode</code>函数实现。</p><p><strong>第三问</strong>：</p><ul><li><strong>elf_load_seg函数</strong>：在该函数处理程序的循环中，当处理到.bss段时，该函数会调用<code>map_page</code>把相应的虚拟地址映射到物理页上，但不会从文件中加载数据。而在<code>map_page</code>的内部会调用<code>load_icode_mapper</code>函数将页面进行映射并根据参数将内容置为0；</li><li><strong>load_icode_mapper函数</strong>：当处理到.bss段时，不从源数据中复制任何内容。最终调用<code>page_insert</code>函数将其置入页表并指定权限。该函数会根据传入的参数在页表项中建立映射关系，并初始化页面为0.</li></ul><h3 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h3><blockquote><p>通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。 </p></blockquote><p>在文件<code>user/sh.b</code>中，我们可以找到如下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdin should be 0, because no file descriptors are open yet</span></span><br><span class="line"><span class="keyword">if</span> ((r = opencons()) != <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;opencons: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stdout</span></span><br><span class="line"><span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在shell进程初始化的时候，由我们规定文件描述符0是标准输入而文件描述符1是标准输出。</p><h3 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h3><blockquote><p>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork一个子 shell，然后子 shell 去执行这条命令。</p><p>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么Linux 的 cd 命令是内部命令而不是外部命令？</p></blockquote><p>在文件<code>shell.c</code>的<code>main</code>函数中有如下核心代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="keyword">if</span> (interactive) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n$ &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">readline(buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (echocmds) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;# %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">runcmd(buf);</span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait(r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知在MOS中我们用到的<code>shell</code>命令除了<code>echocmds</code>和注释两种情况外，都需要<code>fork</code>一个子shell来处理输入的命令。</p><p>Linux的cd指令使用频率较高，若设置为外部指令必然会在<code>cd</code>的时候多次调用<code>fork</code>生成子进程，这显然是低效的。将其设置为内部指令可以切实提高我们操作系统的效率。</p><h3 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h3><blockquote><p>在你的 shell 中输入命令 ls.b | cat.b &gt; motd。</p><ul><li>请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？</li><li>请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul></blockquote><p><strong>第一问</strong>：</p><p>直接运行该命令得到如下输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[00002803] pipecreate </span><br><span class="line">[00003805] destroying 00003805</span><br><span class="line">[00003805] free env 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00004006] destroying 00004006</span><br><span class="line">[00004006] free env 00004006</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free env 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free env 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><p>通过<code>debugf</code>打log得到输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[00002803] is forked in shell! [1]</span><br><span class="line">[00002803] pipecreate </span><br><span class="line">00002803 forked 00003004</span><br><span class="line">[00002803] is calling a spawn function</span><br><span class="line">[00003004] is calling a spawn function</span><br><span class="line">00002803 spawns 00003805</span><br><span class="line">00003004 spawns 00004006</span><br><span class="line">[00003805] destroying 00003805</span><br><span class="line">[00003805] free env 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00004006] destroying 00004006</span><br><span class="line">[00004006] free env 00004006</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free env 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free env 00002803</span><br><span class="line">i am killed ... </span><br></pre></td></tr></table></figure><p>也就是说整个总共<code>spawn</code>了两次，分别是由最初被<code>fork</code>出的<code>2803</code>进程<code>spawn</code>出了<code>3805</code>进程，以及<code>3004</code>(被2803进程在<code>parsecmd</code>时<code>fork</code>得到)进程<code>spawn</code>出了<code>4006</code>进程。</p><p><strong>第二问</strong>：</p><p>观察到了四次进程销毁，下面分别介绍：</p><ul><li><strong>2803进程</strong>：由主shell进程fork出来的子shell进程，用于解析并执行当前命令；</li><li><strong>3004进程</strong>：由<strong>2803</strong>进程fork出来的子进程，用于解析并执行管道右端的命令；</li><li><strong>3805进程</strong>：由<strong>2803</strong>进程spawn出来的子进程，用于执行管道左边的命令；</li><li><strong>4006进程</strong>：由<strong>3004</strong>进程spawn出来的子进程，用于执行管道右边的命令；</li></ul><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><p>本次实验是在整个<code>MOS</code>操作系统的实现过程中，在层次角度考虑是最顶层的一次实验，因此本次实验的综合性相对较强。</p><p>在我看来，本次实验的主要难点集中在对整个shell程序运行流程的理解，具体地可以分为以下几点：</p><ul><li>理清shell相关函数的作用以及相互之间的调用关系；</li><li>对<code>spawn</code>函数的理解与填写，这要结合包括Lab1，Lab3，Lab4，Lab5等实验的知识点诸如<code>fork</code>，ELF文件的加载等进行理解；</li><li>对于整个shell的运行流程的理解。</li></ul><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>本次实验任务相对来说较少，较为简单(除去<code>spawn</code>函数的理解与填写有些耗费精力)，但是在完成实验的基础上，仍需要下功夫去研究新增的代码的功能和作用。</p><p>好感慨啊，一学期的os实验就这么告一段落了，实验任务量很大，但是今年os实验在课程组的各位佬的改造下，至少对于我这种菜鸡来说已经是十分友好了。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> shell </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab05实验报告</title>
      <link href="/2023/05/23/OS-Lab5/"/>
      <url>/2023/05/23/OS-Lab5/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><blockquote><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种<strong>错误</strong>的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p></blockquote><p>对于这个问题，可以分别站在读请求和写请求两个角度来考虑。</p><p>对于写请求，如果使用Write-Back策略对Cache进行更新，且通过kseg0段进行设备读写的话，假如说对某一个设备有连续的写入请求，那么在第一次读该设备I/O端口之前，我们的计算机所做的就只是不断地将Cache中映射到I/O端口的’dirty’表项进行更新，而不会真正写入到设备的I/O端口中去。</p><p>而对于读请求，以实验中的IDE磁盘为例，在对磁盘进行第n次连续写入的请求后(根据上述推理可知实际上并未进行这个写入操作)，然后对上一次操作的状态返回值进行读取，而这时候可能会错误地从设备中返回一个非0值，而我们的写入操作并未实际执行，这样就产生了错误。</p><h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？ </p></blockquote><p>查阅代码可知有<code>#define BY2BLK BY2PG</code>，也就是说一个磁盘块大小和一个物理页大小相等，为4096byte。而代码对一个磁盘块中最多含有的文件控制块数有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK / sizeof(struct File))</span></span><br></pre></td></tr></table></figure><p>通过在测试程序中编写语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debugf(<span class="string">&quot;FILE2BLK is: %d \n&quot;</span>, FILE2BLK);</span><br></pre></td></tr></table></figure><p>输出得到：<code>FILE2BLK is: 16 </code>，也就是说，一个磁盘块最多含有16个文件控制块。</p><p>其实观察宏定义也不难得出一个文件控制块的大小：<code>#define BY2FILE 256</code>，而<code>File</code>结构体是这样定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line"><span class="type">uint32_t</span> f_size; <span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type; <span class="comment">// file type</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line"><span class="type">uint32_t</span> f_indirect;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure><p>可见该结构体被<code>f_pad</code>填充为了256字节</p><p>而一个目录最多能够指向<code>4096/4 = 1024</code>个磁盘块，也就是说一个目录下最多有<code>1024 * 16 = 16384</code>个文件。</p><p>而我们的文件系统支持的单个文件最大为<code>1024 * 4KB = 4MB</code>。宏定义里也给出了：<code>#define MAXFILESIZE (NINDIRECT * BY2BLK)</code></p><h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p></blockquote><p>由<code>#define DISKMAX 0x40000000</code>可知我们实验使用的内核支持的 最大磁盘大小为1GB。</p><h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><blockquote><p>在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</p></blockquote><p>在我看来，这些头文件中的与文件控制块<code>FILE</code>和磁盘控制块有关的宏较为重要，能帮助我们理解相关概念。</p><p>首先，“磁盘块”这个概念是我们对磁盘的抽象，一个磁盘块(block)的字节大小为<code>BY2BLK = 4096byte</code>（定义在user/include/fs.h中）。</p><p>而定义在user/include/fs.h中的<code>File</code>结构体则是我们所谓的文件控制块，这是操作系统用于存储文件相关信息并对文件进行管理的数据结构。而同文件下的宏<code>FILE2BLK</code>是用来表示一个磁盘块最多存储的文件控制块数，我们就可以得知在磁盘中，是“文件控制块装在磁盘控制块里”这样一个结构。</p><h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><blockquote><p>在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</p></blockquote><p>考虑如下用户态程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> r, fdnum, n;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">fdnum = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>((r = fork()) == <span class="number">0</span>)&#123; <span class="comment">//子进程</span></span><br><span class="line">    n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">    debugf(<span class="string">&quot;The buffer of child is \&quot;%s\&quot;\n&quot;</span>, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n = read(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">    debugf(<span class="string">&quot;The buffer of father is \&quot;%s\&quot;\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而文件<code>/newmotd</code>内容为：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a NEW message of the day!</span><br></pre></td></tr></table></figure><p>运行输出结果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The buffer of father is &quot;This &quot;</span><br><span class="line">The buffer of child is &quot;is a &quot;</span><br></pre></td></tr></table></figure><p>可见fork前后的父子进程共享了文件描述符中的<code>fd_offset</code>定位指针，从而可以证明父子进程共享了文件描述符和文件定位指针。</p><h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><blockquote><p>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span> <span class="comment">// 既是磁盘上的物理实体，又是文件系统服务进程中的内存数据</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名</span></span><br><span class="line"><span class="type">uint32_t</span> f_size; <span class="comment">// 文件/目录占据存储空间的大小</span></span><br><span class="line"><span class="type">uint32_t</span> f_type; <span class="comment">// 类型：&#123;文件 or 目录&#125;</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">// 直接指向包含文件内容的磁盘块的10个直接指针</span></span><br><span class="line"><span class="type">uint32_t</span> f_indirect; <span class="comment">// 指向存储指向其它文件内容磁盘块的磁盘块的间接指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// 指向该文件所属目录的指针, 只在内存中有效.</span></span><br><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)]; <span class="comment">// 用于保证该结构体是256字节对齐的pad字段</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span> <span class="comment">// 内存数据</span></span><br><span class="line">u_int fd_dev_id; <span class="comment">// 标识外设类型的字段，在语义上和`Dev`结构体中的`dev_id`字段是等价的</span></span><br><span class="line">u_int fd_offset; <span class="comment">// 指示文件读写偏移量的字段，指示当前读写到哪里的一个“指针”，可以被`seek`,`read`,`write`等函数修改</span></span><br><span class="line">u_int fd_omode; <span class="comment">// 表示文件打开的操作权限，查阅代码可知具体有取值集合&#123;O_RDWR，O_WRONLY，O_RDONLY&#125;三种分别对应读写，只读，只写</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file descriptor + file 实际上是对`Fd`指针的另一种解释形式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span> <span class="comment">// 内存数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">u_int f_fileid; <span class="comment">// 指文件本身</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">// 指文件id</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h3><blockquote><p>图5.7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><p>单就箭头形状而言，图5.7中有两种箭头，分别是实心箭头和虚线箭头，查阅资料可知实心箭头代表<strong>同步消息</strong>而虚线箭头则代表<strong>返回消息</strong>。</p><p>站在更进一步的角度考虑，从<code>init</code>进程生命线出发的两个<code>ENV_CREAT</code>箭头代表了<code>init</code>进程对<code>fs_serv</code>和<code>user_env</code>进程的创建，而<code>IPC</code>框内的两个箭头则代表了用户进程和文件系统进程之间的交互，即用户进程的<strong>请求</strong>与文件系统对请求的<strong>响应</strong>。</p><p>我们的操作系统设计进程间通信主要涉及到如下文件：<code>user/lib/file.c</code>，<code>user/lib/fsipc.c</code>，<code>user/lib/serv.c</code>。</p><p>调用基本流程是：首先，用户态程序调用<code>user/lib/file.c</code>中的如<code>open</code>等文件操作函数，再由这些函数调用<code>user/lib/fsipc.c</code>中对应的<code>fsipc_*</code>函数，这些<code>fsipc_*</code>再进一步调用<code>fsipc</code>函数并传入请求的操作类型的<strong>类型号</strong>，由<code>fsipc</code>函数使用<code>ipc_*</code>与文件系统进程进行进程通信从而进行交互。</p><p>而对于文件系统服务进程<code>fs_serv</code>，它在一个<code>for(;;)</code>的大循环中接收各个进程通过<code>ipc_send</code>发来的请求并根据传入的类型号，由一个<code>switch-case</code>结构来确定由哪一个<code>serve_*</code>函数来处理这个文件操作请求，最终通过<code>ipc_send</code>向用户进程返回操作结果。</p><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><ul><li>新增代码量较大，实验练习填写的代码只占新增代码的很小一部分，若想对<code>mos</code>的文件系统结构，运作流程以及磁盘的结构有更深一步的理解，需要在完成代码填写的基础上对代码进行整体性的阅读与梳理。</li><li>在<strong>用户进程与文件系统交互</strong>这一部分，函数调用链很深，需要跨很多文件去理解交互和调用的过程，其实在lab5-2的exam的文件修改量就可以看出来这次的复杂度上升的很陡峭。</li></ul><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>应该是几次实验里面需要阅读的代码量最大的一次了，引入了诸如文件描述符，磁盘块等一系列概念，需要认真阅读下发的代码头文件以及注释，结合指导书进行理解。</li><li>对于用户进程向文件系统发送请求以及文件系统响应请求的过程，除了认真阅读代码外，画出大致的草图也可以帮助我们对这个过程的调用链进行理解。</li></ul><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab4 实验报告</title>
      <link href="/2023/05/07/OS-Lab4/"/>
      <url>/2023/05/07/OS-Lab4/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><blockquote><p>思考并回答下面的问题：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall留下的信息吗？</li><li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样<br>的参数的？</li><li>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul></blockquote><p>答：</p><ul><li><p>内核通过使用<code>SAVE_ALL</code>宏来保存现场，该宏的实现是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">move    k0, sp</span><br><span class="line">bltz    sp, 1f</span><br><span class="line">li      sp, KSTACKTOP</span><br><span class="line">1:</span><br><span class="line">subu    sp, sp, TF_SIZE</span><br><span class="line">sw      k0, TF_REG29(sp) // tf中的栈指针</span><br><span class="line">mfc0    k0, CP0_STATUS</span><br><span class="line">sw      k0, TF_STATUS(sp)</span><br><span class="line">mfc0    k0, CP0_CAUSE</span><br><span class="line">sw      k0, TF_CAUSE(sp)</span><br><span class="line">mfc0    k0, CP0_EPC</span><br><span class="line">sw      k0, TF_EPC(sp)</span><br><span class="line">mfc0    k0, CP0_BADVADDR</span><br><span class="line">sw      k0, TF_BADVADDR(sp)</span><br><span class="line">mfhi    k0</span><br><span class="line">sw      k0, TF_HI(sp)</span><br><span class="line">mflo    k0</span><br><span class="line">sw      k0, TF_LO(sp)</span><br><span class="line">sw      $0, TF_REG0(sp)</span><br><span class="line">// ...</span><br><span class="line">// 保存其它通用寄存器($0-$28, $30-$31)</span><br></pre></td></tr></table></figure><p>具体来说，该宏首先将现场的栈指针保存在了k0(为内核保留的寄存器)中，接着，将栈指针寄存器指向了内核栈顶部并为<code>Trap_frame</code>结构体分配了栈空间，最后将CPU所有的现场信息全部保存在内核栈上的<code>TF</code>结构体中。</p></li><li><p><strong>不可以</strong>，就拿$a0来说，在<code>handle_exception</code>函数中，有语句<code>move a0 sp</code>，这句语句的意义是将指向内核栈上的<code>TF</code>结构体的指针作为传递给<code>do_syscall</code>这个handler函数的参数，也就是说，现场已经遭到破坏，我们想要访问调用<code>msyscall</code>时传入的参数，需要通过内核栈上的TF结构体来实现。</p></li><li><p>根据我们前面所述，调用<code>msyscall</code>时的所有现场信息已经保存到内核栈上的<code>TF</code>结构体中了，对于$a0-$a3四个参数我们可以直接通过访问<code>TF</code>结构体中对应的寄存器信息取得:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line">u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>然而对于保存在函数栈帧中的参数，则需要通过<code>TF</code>结构体中保存的现场栈指针来访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u_int *stack_pointer = (u_int *)(tf-&gt;regs[<span class="number">29</span>]);</span><br><span class="line">arg4 = *(stack_pointer + <span class="number">4</span>);</span><br><span class="line">arg5 = *(stack_pointer + <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>也就是说，通过保存现场并使用现场数据中保存的参数就可以让<code>sys_*</code>函数在调用时认为自己被传入了和调用<code>msyscall</code>时相同的参数。</p></li><li><p>内核处理系统调用的过程中对<code>Trapframe</code>做了两点改变:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">tf-&gt;regs[<span class="number">2</span>] = return_val;</span><br></pre></td></tr></table></figure><p>修改epc是为了在返回用户态后程序从<code>syscall</code>指令的下一条开始运行，不进行该操作会重复运行<code>syscall</code>进入内核态；而修改<code>TF</code>中的v0寄存器则是为了向用户态传递返回值。</p></li></ul><h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><blockquote><p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？ </p></blockquote><p>在该函数中，我们是这样从<code>envs</code>数组中取出进程控制块的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = &amp;envs[ENVX(envid)];</span><br></pre></td></tr></table></figure><p>而使用到的<code>ENVX</code>宏以及用来生成进程id的<code>mkenvid</code>函数是这样实现的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENVX(envid) ((envid) &amp; (NENV - 1))</span></span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line"><span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是一个32位进程编号的结构是：低10位索引该编号对应进程控制块在<code>envs</code>中的偏移量，而高22位则表示该进程被分配的序号，也就是说可能会出现使用一个<code>envid</code>在<code>envs</code>中索引到的进程控制块中的<code>envid</code>和我们预期的不符的情况(哈希冲突)。</p><h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><blockquote><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与envid2env() 函数的行为进行解释。</p></blockquote><p>首先，<code>envid2env</code>函数提供了一个重要的功能，即：向该函数传入参数0时，该函数返回指向当前运行进程的进程控制块的指针，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(envid == <span class="number">0</span>)&#123; </span><br><span class="line">*penv = curenv;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>而站在用户的角度，在使用诸如<code>syscall_mem_map</code>等系统调用时，会通过传入0这个id来对当前进程进行操作。而若<code>mkenvid</code>在生成进程id时使某个进程的id为0了，这样的调用行为就存在二义性了，即：<strong>无法明确用户制定的进程是当前进程还是那个id为0的进程</strong>。因此，该函数不会返回0。</p><h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><blockquote><p>关于 fork 函数的两个返回值，下面说法正确的是：</p><p>A、fork 在父进程中被调用两次，产生两个返回值<br>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值<br>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值<br>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值 </p></blockquote><p>应当选择C，<code>fork</code>函数的特点就是“调用一次，返回两次”，且在父进程中被调用。</p><h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><blockquote><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。</p></blockquote><p>在函数<code>env_init</code>对所有进程控制块的初始化过程中，使用<code>map_segment</code>函数构造了一个名为<code>base_pgdir</code>的“模板页目录”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base_pgdir = (Pde *)page2kva(p);</span><br><span class="line"></span><br><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG),PTE_G);</span><br><span class="line"></span><br><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS, ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG),PTE_G);</span><br></pre></td></tr></table></figure><p><code>base_pgdir</code>作为一个模板，以<code>PTE_G</code>(无写权限)的权限映射了[UENVS, UVPT)之间的地址空间(即UPAGES和UENVS两个段)。</p><p>而在创建一个新进程，并进行<code>env_setup_vm</code>的过程中，对于每个新创建进程，我们都要将前面所述的<code>base_pgdir</code>这个模板页目录复制到这个新进程的页目录中来，这是为了保证每个进程都能够只读地访问到<code>pages</code>数组和<code>envs</code>数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">       <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br></pre></td></tr></table></figure><p>也就是说，用户空间中的[UPAGES, UVPT)这一段全部进程共享的页面段不需要使用<code>duppage</code>进行复制映射。</p><h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><blockquote><p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：</p><ul><li>vpt 和 vpd 的作用是什么？怎样使用它们？</li><li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种方式来修改自己的页表项吗？</li></ul></blockquote><ul><li><p><code>vpt</code>和<code>vpd</code>是定义在<code>user\lib.h</code>下的一对宏，具体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure><p>它们的作用是将用户进程地址空间中的页表基址和页目录基址以指针的形式封装起来，方便编程时使用以访问页表和页目录。使用上可以当作一般的<code>Pte*</code>指针和<code>Pde*</code>指针使用。</p></li><li><p>根据<code>mmu.h</code>中的地址空间布局图，我们可以知道，在所有进程看来，它自身的页表均分布在[UVPT, ULIM)这段地址空间上，更具体地，所有的进程的页表基址均为<code>UVPT</code>。根据这种统一性，我们可以通过这样一个经由宏定义得到的指针来对进程自身的页表进行存取。</p></li><li><p><code>vpd</code>的基址是由自映射机制推导而来的，这体现出了自映射的设计。</p></li><li><p>不能，用户态下无权修改页表项。</p></li></ul><h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><blockquote><p>在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重<br>入”？</li><li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></blockquote><ul><li>即：在处理A进程的<code>tlb_mod</code>异常时另一进程又触发了该异常。</li><li>我们的MOS操作系统采用的是<strong>微内核</strong>架构，按照微内核的设计理念，我们应当尽可能地将功能实现在用户空间中，精简内核的功能范围。对于页写入异常的处理，也应当遵循这个设计原则。而将异常现场的<code>Trapframe</code>由内核空间复制到用户空间的异常处理栈<code>UXSPACE</code>上的主要目的就是为了让我们用户空间的处理函数<code>cow_entry</code>能够获取到异常现场信息并进行异常处理。</li></ul><h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><blockquote><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？</p></blockquote><p>在用户态处理页写入异常相较于在内核态进行处理的优势在我看来有如下几点：</p><ul><li>遵循了微内核设计原则，将异常处理的操作交给用户进程自己来完成，精简了内核的功能范围；</li><li>将处理的核心逻辑从内核下方到用户态，降低了处理失败对整个操作系统造成的危害与损失。</li></ul><h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><blockquote><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul></blockquote><ul><li><p>因为在父进程调用<code>syscall_exofork</code>的过程中也可能会触发<code>tlb_mod</code>异常。</p></li><li><p>假设这样的情况发生，也就是说父进程的<code>env-&gt;env_user_tlb_mod_entry</code>在调用<code>syscall_exofork</code>时未被正确设置为<code>cow_entry</code>，那么当在exofork的过程中发生了<code>tlb_mod</code>异常，根据如下代码段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作系统会无法处理这个异常并报错。</p></li></ul><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>相较于前几次实验较为顺利的完成过程(在细致阅读指导书以及注释后就能进行正确的函数补全)，本次实验还是踩了一些坑的。</p><h3 id="envid2env"><a href="#envid2env" class="headerlink" title="envid2env"></a>envid2env</h3><p>在补全<code>envid2env</code>函数的时候没怎么带脑子读函数，注意到注释是这么写的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Assign value to &#x27;e&#x27; using &#x27;envid&#x27;. */</span></span><br><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   If envid is zero, set &#x27;penv&#x27; to &#x27;curenv&#x27;.</span></span><br><span class="line"><span class="comment"> *   You may want to use &#x27;ENVX&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br></pre></td></tr></table></figure><p>于是乎，我眼疾手快，直接写下了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">    e = curenv;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在本地测试时出现了疯狂panic报错<code>unreachable code</code>的问题，最终调试时发现，如果这么写，由于没有进程的<code>envid</code>为0，所以在后续逻辑中一定会进入如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并错误返回，导致测试程序无法正常结束，遂改正为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(envid == <span class="number">0</span>)&#123; </span><br><span class="line">*penv = curenv;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">e = &amp;envs[ENVX(envid)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来，不要过分依赖注释，认真读代码，理解代码，还是十分重要的啊！（赞许）</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>不要过分依赖于注释，认真阅读，理解代码的用意才是硬道理。</p><p>print法debug真的很好用！</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用 </tag>
            
            <tag> fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab1 实验报告</title>
      <link href="/2023/04/11/OS-Lab1/"/>
      <url>/2023/04/11/OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><blockquote><p>请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链(<code>gcc</code>、<code>ld</code>、<code>readelf</code>、<code>objdump</code>等)和 MIPS 交叉编译工具链(带有 <code>mips-linux-gnu-</code>前缀)，重复其中的编译和解析过程，观察相应的结果，并解释其中向 <code>objdump</code> 传入的参数的含义。</p></blockquote><hr><p>首先，我们使用<code>objdump --help</code>命令来查看<code>-DS</code>参数的含义，输出结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-D, --disassemble-all    Display assembler contents of all sections</span><br><span class="line"><span class="comment">// 含义为展示所有section的汇编内容</span></span><br><span class="line">-S, --source             Intermix source code with disassembly</span><br><span class="line"><span class="comment">// 同时显示机器源码与反汇编得到的汇编代码</span></span><br></pre></td></tr></table></figure><p>也就是说，这里参数的含义是：<strong>展示二进制文件所有section的反汇编结果，并同时显示机器源码和反汇编得到的汇编代码</strong>。</p><p>使用原生x86工具链的操作流程与结果在指导书中已经十分清晰了，于是我在此不做复述，仅对使用<code>mips</code>交叉编译工具链的实验过程进行记录。</p><p>首先我在空文件夹下创建C文件<code>hello.c</code>，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其使用命令<code>mips-linux-gnu-gcc -E hello.c &gt; cache1</code>，得到的预处理后的文件里只是出现了头文件的内容(只包含printf()的函数头)，并没有出现<code>printf()</code>函数本尊的身影，部分文件内容摘录如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;hello.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再键入命令<code>mips-linux-gnu-gcc -c hello.c</code>对<code>hello.c</code>文件进行编译(不链接)，使用<code>mips-linux-gnu-objdump -DS hello.o &gt; cache1</code>进行反汇编，<code>cache1</code>中的<code>main</code>函数反汇编结果为：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="number">00000000</span> &lt;main&gt;:</span><br><span class="line"> <span class="number">8</span>    <span class="number">0</span>:   <span class="number">27</span>bdffe0        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">32</span></span><br><span class="line"> <span class="number">9</span>    <span class="number">4</span>:   afbf001c        <span class="keyword">sw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">10</span>    <span class="number">8</span>:   afbe0018        <span class="keyword">sw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">11</span>    c:   <span class="number">03</span>a<span class="symbol">0f</span>025        <span class="keyword">move </span>   <span class="built_in">s8</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="number">12</span>   <span class="number">10</span>:   <span class="number">3</span>c1c0000        <span class="keyword">lui </span>    <span class="built_in">gp</span>,<span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>   <span class="number">14</span>:   <span class="number">279</span>c0000        <span class="keyword">addiu </span>  <span class="built_in">gp</span>,<span class="built_in">gp</span>,<span class="number">0</span></span><br><span class="line"><span class="number">14</span>   <span class="number">18</span>:   afbc0010        <span class="keyword">sw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">15</span>   <span class="number">1</span>c:   <span class="number">3</span>c020000        <span class="keyword">lui </span>    <span class="built_in">v0</span>,<span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>   <span class="number">20</span>:   <span class="number">24440000</span>        <span class="keyword">addiu </span>  <span class="built_in">a0</span>,<span class="built_in">v0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">17</span>   <span class="number">24</span>:   <span class="number">8</span>f820000        <span class="keyword">lw </span>     <span class="built_in">v0</span>,<span class="number">0</span>(<span class="built_in">gp</span>)</span><br><span class="line"><span class="number">18</span>   <span class="number">28</span>:   <span class="number">0040</span>c825        <span class="keyword">move </span>   <span class="built_in">t9</span>,<span class="built_in">v0</span></span><br><span class="line"><span class="number">19</span>   <span class="number">2</span>c:   <span class="number">0320</span>f809        <span class="keyword">jalr </span>   <span class="built_in">t9</span></span><br><span class="line"><span class="number">20</span>   <span class="number">30</span>:   <span class="number">00000000</span>        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="number">21</span>   <span class="number">34</span>:   <span class="number">8</span>fdc0010        <span class="keyword">lw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">s8</span>)</span><br><span class="line"><span class="number">22</span>   <span class="number">38</span>:   <span class="number">00001025</span>        <span class="keyword">move </span>   <span class="built_in">v0</span>,<span class="built_in">zero</span></span><br><span class="line"><span class="number">23</span>   <span class="number">3</span>c:   <span class="number">03</span>c0e825        <span class="keyword">move </span>   <span class="built_in">sp</span>,<span class="built_in">s8</span></span><br><span class="line"><span class="number">24</span>   <span class="number">40</span>:   <span class="number">8</span>fbf001c        <span class="keyword">lw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">25</span>   <span class="number">44</span>:   <span class="number">8</span>fbe0018        <span class="keyword">lw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">26</span>   <span class="number">48</span>:   <span class="number">27</span>bd0020        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">32</span></span><br><span class="line"><span class="number">27</span>   <span class="number">4</span>c:   <span class="number">03</span>e00008        <span class="keyword">jr </span>     <span class="built_in">ra</span></span><br><span class="line"><span class="number">28</span>   <span class="number">50</span>:   <span class="number">00000000</span>        <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>而键入命令<code>mips-linux-gnu-gcc -o hello hello.c</code><br>，对源文件<code>hello.c</code>进行编译和链接。再执行命令<code>mips-linux-gnu-objdump -DS hello &gt; cache3</code>，其中的<code>main</code>函数结果反汇编结果如下：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">380</span> <span class="number">004006</span>e0 &lt;main&gt;:</span><br><span class="line"><span class="number">381</span>   <span class="number">4006</span>e0:       <span class="number">27</span>bdffe0        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">32</span></span><br><span class="line"><span class="number">382</span>   <span class="number">4006</span>e4:       afbf001c        <span class="keyword">sw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">383</span>   <span class="number">4006</span>e8:       afbe0018        <span class="keyword">sw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">384</span>   <span class="number">4006</span>ec:       <span class="number">03</span>a<span class="symbol">0f</span>025        <span class="keyword">move </span>   <span class="built_in">s8</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="number">385</span>   <span class="number">4006</span>f0:       <span class="number">3</span>c1c0042        <span class="keyword">lui </span>    <span class="built_in">gp</span>,<span class="number">0x42</span></span><br><span class="line"><span class="number">386</span>   <span class="number">4006</span>f4:       <span class="number">279</span>c9010        <span class="keyword">addiu </span>  <span class="built_in">gp</span>,<span class="built_in">gp</span>,-<span class="number">28656</span></span><br><span class="line"><span class="number">387</span>   <span class="number">4006</span>f8:       afbc0010        <span class="keyword">sw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">388</span>   <span class="number">4006</span>fc:       <span class="number">3</span>c020040        <span class="keyword">lui </span>    <span class="built_in">v0</span>,<span class="number">0x40</span></span><br><span class="line"><span class="number">389</span>   <span class="number">400700</span>:       <span class="number">24440830</span>        <span class="keyword">addiu </span>  <span class="built_in">a0</span>,<span class="built_in">v0</span>,<span class="number">2096</span></span><br><span class="line"><span class="number">390</span>   <span class="number">400704</span>:       <span class="number">8</span>f828030        <span class="keyword">lw </span>     <span class="built_in">v0</span>,-<span class="number">32720</span>(<span class="built_in">gp</span>)</span><br><span class="line"><span class="number">391</span>   <span class="number">400708</span>:       <span class="number">0040</span>c825        <span class="keyword">move </span>   <span class="built_in">t9</span>,<span class="built_in">v0</span></span><br><span class="line"><span class="number">392</span>   <span class="number">40070</span>c:       <span class="number">0320</span>f809        <span class="keyword">jalr </span>   <span class="built_in">t9</span></span><br><span class="line"><span class="number">393</span>   <span class="number">400710</span>:       <span class="number">00000000</span>        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="number">394</span>   <span class="number">400714</span>:       <span class="number">8</span>fdc0010        <span class="keyword">lw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">s8</span>)</span><br><span class="line"><span class="number">395</span>   <span class="number">400718</span>:       <span class="number">00001025</span>        <span class="keyword">move </span>   <span class="built_in">v0</span>,<span class="built_in">zero</span></span><br><span class="line"><span class="number">396</span>   <span class="number">40071</span>c:       <span class="number">03</span>c0e825        <span class="keyword">move </span>   <span class="built_in">sp</span>,<span class="built_in">s8</span></span><br><span class="line"><span class="number">397</span>   <span class="number">400720</span>:       <span class="number">8</span>fbf001c        <span class="keyword">lw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">398</span>   <span class="number">400724</span>:       <span class="number">8</span>fbe0018        <span class="keyword">lw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">399</span>   <span class="number">400728</span>:       <span class="number">27</span>bd0020        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">32</span></span><br><span class="line"><span class="number">400</span>   <span class="number">40072</span>c:       <span class="number">03</span>e00008        <span class="keyword">jr </span>     <span class="built_in">ra</span></span><br><span class="line"><span class="number">401</span>   <span class="number">400730</span>:       <span class="number">00000000</span>        <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>可以观察到：首先，<code>main</code>函数入口在链接后被分配了在<code>0x4006e0</code>的地址，其次，被用于存储跳转到<code>printf()</code>函数的地址的<code>t9</code>寄存器的值也不再是默认值了。</p><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><blockquote><p>思考下述问题：</p><p>-尝试使用我们编写的 <code>readelf</code> 程序，解析之前在 <code>target</code> 目录下生成的内核ELF文件。</p><p>-也许你会发现我们编写的 <code>readelf</code> 程序是不能解析 <code>readelf</code> 文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？(hint: 尝试使用 <code>readelf -h</code>，并阅读 <code>tools/readelf</code> 目录下的 <code>Makefile</code>，观察 <code>readelf</code> 与 <code>hello</code> 的不同)</p></blockquote><hr><p>使用命令<code>./readelf ../../target/mos</code>对内核ELF文件进行解析，得到如下结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:0x0</span><br><span class="line">1:0x80010000</span><br><span class="line">2:0x80011df0</span><br><span class="line">3:0x80011e08</span><br><span class="line">4:0x80011e20</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br><span class="line">17:0x0</span><br></pre></td></tr></table></figure><p>对于我们编写的<code>readelf</code>程序无法解析<code>readelf</code>文件本身的原因，我先放结论：这是因为<strong>我们编写的readelf程序只能够解析32位的ELF文件，而我们编写的readelf程序本身是64位的ELF文件，因此无法被解析。</strong></p><p>首先，我们使用<code>readelf -h</code>命令分别对<code>hello</code>和<code>readelf</code>文件进行解析，得到的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF32</span><br><span class="line"></span><br><span class="line"><span class="comment">// readelf</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br></pre></td></tr></table></figure><p>而目录下<code>Makefile</code>中对<code>hello</code>的编译命令为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> -m32 -static -g</span><br></pre></td></tr></table></figure><p>其中<code>-m32</code>参数的作用是在64位操作系统下编译生成32位可执行文件，这更加佐证了我的观点：hello是一个32位的可执行文件。</p><p>为了进一步佐证我的观点，我编写了一个完全相同的<code>hello2.c</code>文件，并使用<code>gcc -o hello2 hello2.c</code>，接着用<code>./readelf hello2</code>命令尝试对<code>hello2</code>文件进行解析，未果。再次使用<code>readelf -h hello2</code>，得到如下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br></pre></td></tr></table></figure><p>可知，我们编写的<code>readelf</code>程序无法解析自身的原因是该程序只能解析32位的elf文件。</p><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><blockquote><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000(其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址)，但实验操作系统的内核入口并没有放在上电启动地址，而是按照<strong>内存布局图</strong>放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？(Hint: <strong>思考实验中启动过程的两阶段分别由谁执行</strong>)</p></blockquote><hr><p>根据指导书附录，我们可以知道，真实操作系统启动的时候，在内核被加载运行之前是会经过两个由<code>bootloader</code>控制进行的阶段(stage1，stage2)的。其中，stage1完成的工作为：基础的硬件初始化，为stage2初始化RAM，载入stage2到RAM，<strong>设置堆栈</strong>并跳转到stage2入口；而stage2完成的工作为：初始化该阶段所需的硬件设备，载入内核和根文件系统，<strong>最后</strong>才会为内核设置启动参数并跳转到内核入口。</p><p>也就是说，真实的操作系统的启动流程中，内核并不是在一开始就直接被加载到内存上，而是先由<code>bootloader</code>逐步对硬件设备进行控制与初始化，在硬件初始化完成后再将硬件的控制权交给操作系统的。</p><p>而我们的实验编写的MOS操作系统的运行和现实不同的一点是，它是在GXemul仿真器上运行的。而GXemul仿真器支持直接加载ELF格式的内核文件，也就是说我们在实验中，因为仿真器已经提供了本由<code>bootloader</code>的引导功能(即硬件已经被初始化)，更通俗点讲，就是需要<code>bootloader</code>程序去做的 <strong>“盘活硬件”的脏活儿</strong> 已经不用做了，启动的时候也不需要从 <strong><code>bootloader</code>程序的入口</strong> 开始运行了。所以在启动时我们只需要通过<code>Linker Script</code>保证将内核ELF文件加载到内存的合适位置上就好。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>我认为本次实验就代码实现上并不算困难。那么难点在哪里呢？我想难主要难在 <strong>“带着镣铐跳舞”</strong>。本次实验让我明白操作系统实验不是像以往课程实验那样，自己从头到尾实现一个程序，而是在别人的代码框架上做补全。这就要求我设计程序的基础不是我的架构设计，而是这套代码本身的架构设计。我的程序设计是建立在对涉及到的相关代码提供的“基础设施”以及设计思路的基础之上的，而不是我想怎么来就怎么来。</p><h2 id="我的心得体会"><a href="#我的心得体会" class="headerlink" title="我的心得体会"></a>我的心得体会</h2><p>跨多个代码文件进行阅读并总结思考编码方案，这对我这样的没有接触过大项目的人而言是一个很有挑战性的过程，希望我的工程设计和把控能力能在本学期的操作系统课程中取得锻炼和进步。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab2 实验报告</title>
      <link href="/2023/04/11/OS-Lab2/"/>
      <url>/2023/04/11/OS-Lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><blockquote><p>Q:在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？</p></blockquote><p><strong>A</strong>:</p><ul><li>在编写的C程序中，指针变量中存储的地址是虚拟地址；</li><li>MIPS汇编程序中lw和sw使用的也是虚拟地址。</li></ul><hr><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><blockquote><p>Q1:从可重用性的角度，阐述用宏来实现链表的好处。<br>Q2:查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异</p></blockquote><p><strong>A1</strong>:</p><p>用宏实现链表的好处可以通过将其与通过函数实现进行对比来体现。就我们实验中<code>Page</code>组成的链表为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span>&#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        pp_link&#123;</span></span><br><span class="line"><span class="comment">            struct Page *le_next;</span></span><br><span class="line"><span class="comment">            struct Page **le_prev;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设我们有一个链表头<code>struct Page* head</code>指向的链表，若我们要编写一个在该链表元素<code>listelm</code>后插入元素<code>elm</code>的函数，我们应当做如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_after</span><span class="params">(<span class="keyword">struct</span> Page* listelm, <span class="keyword">struct</span> Page* elm)</span>;</span><br></pre></td></tr></table></figure><p>而若我们定义另一种链表单元如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_Page</span>&#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        pp_link&#123;</span></span><br><span class="line"><span class="comment">            struct Page *le_next;</span></span><br><span class="line"><span class="comment">            struct Page **le_prev;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    u_long some_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个插入代码就无法在该类型上复用了。而考虑宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field)                                                    \</span></span><br><span class="line"><span class="meta">        do &#123;                                                                                       \</span></span><br><span class="line"><span class="meta">                (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;                                   \</span></span><br><span class="line"><span class="meta">                LIST_NEXT((elm), field) = (listelm);                                               \</span></span><br><span class="line"><span class="meta">                *(listelm)-&gt;field.le_prev = (elm);                                                 \</span></span><br><span class="line"><span class="meta">                (listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);                               \</span></span><br><span class="line"><span class="meta">        &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>首先无需考虑链表的<strong>类型命名</strong>，也无需考虑链表的<strong>指针域命名</strong>(传入替换即可)，更无需考虑和插入操作无关的除指针域结构体之外的<strong>数据域组成</strong>，复用性大大提高。</p><p><strong>A2</strong>:</p><p><strong>插入操作：</strong></p><p>单向链表在进行<strong>给定节点前插</strong>的操作时，由于无法通过给定结点访问到<strong>前序节点</strong>的指针域，因此需要对链表从头进行一个事件复杂度为<code>O(n)</code>的遍历，找到前序节点，才能完成前插操作；<br>而循环链表和双向链表因为指针域中多了<strong>指向前序节点后向指针的二级指针</strong>，因此只通过给定节点就可以访问到前序节点的后续指针，因此可以以<code>O(1)</code>的效率完成前插。</p><p>而循环链表的头节点指针域是由一对分别指向链表头部和尾部的指针组成的，因此在执行尾插时无需像双向链表和单向链表一样进行复杂度为<code>O(n)</code>的遍历。</p><p><strong>删除操作：</strong></p><p>依然来看单向链表。如果希望删除单向链表中的任意给定节点，需要的操作是将前序节点的后向指针指向给定节点的后续节点，这依然牵扯到前序节点指针域的访问，因此删除操作也需要<code>O(n)</code>的遍历，而双向链表和循环链表则具有<code>O(1)</code>的复杂度。</p><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><blockquote><p>Q:请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125;* pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125; lh_first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A</strong>:<br>答案是<strong>C选项</strong>。<code>Page_list</code>结构体中只存了一个指向链表第一个元素的<code>lh_first</code>指针，而阅读代码我们可以知道，<code>Page_list</code>指向的<code>Page</code>链表单元的结构是:名为<code>pp_link</code>的指针域和标记页面引用次数的数据域<code>pp_ref</code>，其中<code>pp_link</code>内包含后向一级指针<code>le_next</code>和前向二级指针<code>le_prev</code>。</p><hr><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><blockquote><p>Q1:请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。<br>Q2:请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</p></blockquote><p><strong>A1:</strong><br>引入虚拟内存的核心目的在于：为每个进程提供一个<strong>独立的内存视图</strong>。也就是说，每个进程都有自己独立的地址空间，仅凭借虚拟地址无法完成到物理地址的索引，通过<code>ASID</code>来判断该va属于哪个地址空间就十分必要了。</p><p><strong>A2:</strong></p><p><code>ASID</code>段的位数为6，也就是说理论上R3000可以容纳不同的地址空间的最大数量为<code>2^6=64</code>个。</p><p>而若当前同时存在的地址空间超过64时，会由操作系统进行<strong>ASID flushing</strong>。具体地讲，就是：所有任务的ASID被取消分配(de-assigned)，TLB被刷新；当每个任务被重新输入(re-entered)时，会被赋予新的<code>ASID</code>。<strong>这一过程是不常发生的</strong>。</p><hr><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><blockquote><p>Q1:tlb_invalidate 和 tlb_out 的调用关系？<br>Q2:请用一句话概括 tlb_invalidate 的作用。<br>Q3:逐行解释 tlb_out 中的汇编代码。</p></blockquote><p><strong>A1:</strong><br><code>tlb_out</code>是被<code>tlb_invalidate</code>调用的。</p><p><strong>A2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlb_invalidate(u_int asid, u_long va);</span><br></pre></td></tr></table></figure><p>用于删除TLB中<code>asid</code>指定的地址空间下，<code>va</code>所对应虚拟页面的表项。</p><p><strong>A3:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line"> .<span class="built_in">set</span> noreorder</span><br><span class="line">        mfc0    t0, CP0_ENTRYHI <span class="comment">// 保存现场</span></span><br><span class="line">        mtc0    a0, CP0_ENTRYHI <span class="comment">// 将`Key`写入`ENTRYHI`</span></span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        tlbp <span class="comment">// 在TLB中查找Key对应的表项</span></span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        mfc0    t1, CP0_INDEX <span class="comment">// 将查找结果写入t1寄存器</span></span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">        bltz    t1, NO_SUCH_ENTRY <span class="comment">// 若未查找到(index &lt; 0), 则直接返回，若找到，进行下述流程</span></span><br><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">        mtc0    zero, CP0_ENTRYHI  <span class="comment">// 向`ENTRYHI`写入0</span></span><br><span class="line">        mtc0    zero, CP0_ENTRYLO0 <span class="comment">// 向`ENTRYLO`写入0</span></span><br><span class="line">        nop</span><br><span class="line">        tlbwi <span class="comment">// 将`INDEX`指定的表项的`KEY`和`VALUE`全置0</span></span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">        mtc0    t0, CP0_ENTRYHI <span class="comment">// 恢复现场</span></span><br><span class="line">        j       ra <span class="comment">// 函数返回</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><p>解答如上。</p><hr><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><blockquote><p>Q1:简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。<br>Q2:简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</p></blockquote><p><strong>A1:</strong><br><strong>地址空间大小:</strong> x86 的地址空间是 32 位或 64 位，而 MIPS 的地址空间通常是 32 位。这意味着 x86 可以支持更大的内存容量。<br><strong>缓存一致性协议</strong>：x86 使用缓存一致性协议（如MESI协议），用于维护多个CPU之间的缓存一致性。而 MIPS 通常不包括这样的协议，这意味着在多CPU系统中，需要使用额外的硬件或软件来实现缓存一致性。</p><p><strong>A2:</strong><br><strong>地址空间大小</strong>：RISC-V 的地址空间可以是 32 位或 64 位，而 MIPS 的地址空间通常是 32 位。这意味着 RISC-V 可以支持更大的内存容量。<br><strong>页面大小</strong>：RISC-V 支持多种页面大小，包括 4KB、8KB、16KB、32KB、64KB、128KB、256KB 和 512KB。而 MIPS 可能只支持某些特定的页面大小，比如 4KB 和 16KB。</p><hr><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><blockquote><p>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表<strong>索引</strong>都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。<br>现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：<br>Q1:三级页表页目录的基地址。<br>Q2:映射到页目录自身的页目录项（自映射）。</p></blockquote><p><strong>A1:</strong></p><p>单个页面大小为<code>4KB</code>，则二级页表区域所占的空间大小为<code>4KB * 512 * 512 = 1GB</code>，一级页表区域所占空间大小为<code>4KB * 512 = 2MB</code>。我们不妨进行改写，二级页表基地址为<code>PT2base = PTbase</code>，一级页表基地址为 <code>PT1base</code>，而页目录基地址为<code>PDbase</code>。则可知<code>PT2base = PT1base + 2M * (PT1base / 512G)</code>，而<code>PDbase = PT2base + 4K * ((PT2base - PT1base) / 1G)</code>。</p><p><strong>A2:</strong><br>设该页目录项的地址为<code>PDitem</code>，则有<code>PDitem = PT2base + 8 * ((PDbase - PT2base) / 2M)</code>。</p><hr><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><p>本次实验的难点主要可以概括为以下几点：</p><h3 id="虚拟地址vs物理地址"><a href="#虚拟地址vs物理地址" class="headerlink" title="虚拟地址vs物理地址"></a>虚拟地址vs物理地址</h3><p>在完成本次实验的过程中，尽管实验代码已经在<code>pmap.h</code>和<code>mmu.h</code>为我们配备好了如下各种在本次实验的<code>kseg0</code>段上，虚拟地址与物理地址互相转化的内联函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2ppn</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">va2pa</span><span class="params">(Pde *pgdir, u_long va)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无需在实验过程中为各种转化的具体实现抓耳挠腮，只需调用就好。但难点就在于我在完成实验的过程中需要对<code>虚拟地址</code>和<code>物理地址</code>斤斤计较。我在实验中总结的经验是：编写代码的我们在使用指针时是站在<strong>程序员视角</strong>的，也就是说我们操纵的<strong>一切指针</strong>都存储着将来这段程序对应进程下的虚拟地址，而物理地址则是一个我们需要通过特殊手段转化得到的数据。</p><p>本次实验中需要注意页目录项中存储的<strong>页表基地址</strong>和页表项中存储的<strong>页基地址</strong>均为物理地址。</p><h3 id="理解整个内存管理体系的结构"><a href="#理解整个内存管理体系的结构" class="headerlink" title="理解整个内存管理体系的结构"></a>理解整个内存管理体系的结构</h3><h4 id="页控制块和空闲链表"><a href="#页控制块和空闲链表" class="headerlink" title="页控制块和空闲链表"></a>页控制块和空闲链表</h4><p><strong>页控制块</strong>是<code>pages</code>指针指向的一片连续的<code>Page</code>结构体，每一个<code>Page</code>结构体映射着一个物理页框。</p><p><strong>空闲链表</strong>是以<code>page_free_list</code>为表头的一个双向链表，主要作用是将<code>pages</code>数组中所有空闲页面控制块串联起来，方便空闲页面的分配。</p><h4 id="页表项PTE和页目录项PDE"><a href="#页表项PTE和页目录项PDE" class="headerlink" title="页表项PTE和页目录项PDE"></a>页表项PTE和页目录项PDE</h4><p>首先<code>grep</code>一下可以发现在<code>mmu.h</code>里面有<code>typedef u_long Pde;</code>以及<code>typedef u_long Pte;</code>，可知这二者本质上是32位无符号整数。</p><p>而其结构也值得注意。指导书中给出的PDE结构图如下：</p><p><img src="pde.png" alt="PDE"></p><p>其实这张图还挺有迷惑性的，让人第一眼以为要取出这里的页表基地址需要：<code>address = pde &gt;&gt; 12</code>，然而当我看到<code>mmu.h</code>如下的宏我明白了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure><p>原来只需要低12位清零就好了，也就是说<code>PDE</code>和<code>PTE</code>中存储的物理地址要取得，是需要将低十二位清理，而并不是右移12位。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>在照着指导书进行实验代码编写受阻时，不妨向前翻一两页，很有可能会找到漏读的关键信息。</li><li><strong>指导书不能只囫囵吞枣读一遍！指导书不能只囫囵吞枣读一遍！指导书不能只囫囵吞枣读一遍！</strong></li><li>学习新概念时，不仅要记住这个概念长什么样，还要<strong>理解这个概念为什么长这样</strong>。就拿这次实验举个例子，我在写物理内存管理这一部分的时候就有很多疑惑：为什么同时有<code>pages</code>和<code>page_free_list</code>两个变量在管理页面控制块？而且为什么明明是一片连续的结构体数组，结构体里面还套了个链表的指针域，这玩意怎么一会儿数组一会儿链表的？这些问题在后面写虚拟内存管理的那部分的时候得到了解答，原来链表和数组的形式并不冲突，在<code>pages</code>数组上穿起链表是为了更高效地检索和获取空闲的物理页面，便于后续的页面分配工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab3 实验报告</title>
      <link href="/2023/04/11/OS-Lab3/"/>
      <url>/2023/04/11/OS-Lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><blockquote><p>请结合 MOS 中的页目录自映射应用解释代码中<code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>的含义。</p></blockquote><p>在<strong>MOS中的页目录自映射应用</strong>中提到：<u>而 MOS 中，将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000（共 4MB）区域，这意味着 MOS 中允许在用户态下通过 UVPT 访问当前进程的页表和页目录。</u>结合<code>mmu.h</code>中的宏定义<code>#define UVPT (ULIM - PDMAP)</code>，我们可以得知<code>UVPT</code>即为用户地址空间（虚存）中起<strong>始页表项的地址</strong>。</p><p>设映射到页目录自身的表项为页目录的第<code>i</code>项，页目录基地址为<code>base1</code>，页表基地址为<code>UVPT</code>基于自映射关系，我们可以得出如下关系式：</p><p><img src="expr.png" alt="公式"></p><p>解得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = UVPT &gt;&gt; <span class="number">22</span>;</span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">i = PDX(UVPT);</span><br></pre></td></tr></table></figure><p>基于上述分析不难理解，这条语句是将页目录的起始物理地址自映射到对应的页目录项。</p><hr><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><blockquote><p><code>elf_load_seg</code>以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。请你找到与之相关的<code>data</code>这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote><p><strong>来源</strong>：<br>在<code>include/elf.h</code>中可以找到<code>typedef int (*elf_mapper_t)(void *data, u_long va, size_t offset, u_int perm, const void *src,size_t len);</code>这样一条语句。可知<code>void *data</code>这一参数的来源是<code>elf_mapper_t</code>这一函数指针类型的形参列表。</p><p><strong>作用</strong>：<br>在<code>env.c</code>中的<code>load_icode</code>函数中对<code>elf_load_seg</code>有如下调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e)</span><br></pre></td></tr></table></figure><p>在形参<code>void *data</code>的位置传入了进程控制块指针<code>e</code>。进一步地，我们阅读<code>load_icode_mapper</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    page_alloc(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *dst = (<span class="type">void</span> *)page2kva(p) + offset;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid,p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知<code>env</code>这个结构控制块指针在<code>load_icode_mapper</code>这个回调函数里的作用是为<code>page_insert</code>函数提供了参数<code>env-&gt;env_pgdir</code>和<code>env-&gt;env_asid</code>。在我看来，<code>elf_load_seg</code>是一个被要求<strong>满足多种调用需求的函数</strong>，而对不同调用需求的满足则是通过传入不同的<code>mapper</code>回调函数和<code>data</code>函数指针来实现的。而又因为需求不同，传入<code>data</code>指针的类型也会存在差异，因此，采用以<code>void</code>类型传入，在对应的<code>mapper</code>回调函数中进行相应的转型可以极大程度上提升<code>elf_load_seg</code>函数的<strong>可复用性</strong>。</p><p>没有这个参数是<strong>万万不能</strong>的，因为这样就无法满足回调函数的参数需求了。</p><hr><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><blockquote><p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote><ul><li>如果段的虚拟地址与页面边界不对齐，需要将二进制文件的前一个页面映射到虚拟地址空间中。偏移量为 <code>offset = va - ROUNDDOWN(va, BY2PG)</code>。</li><li>如果二进制文件大小小于一个页面，则需要将该页面映射到虚拟地址空间中。此时，需要使用<code>map_page</code>回调函数来分配和映射物理页面。</li><li>如果二进制文件大小大于一个页面，则需要将文件的每一页映射到虚拟地址空间中。同样需要使用<code>map_page</code>回调函数来进行物理页面映射。</li><li>如果二进制文件大小小于段的内存大小，则需要继续分配和映射页面，直到达到段的内存大小为止。</li></ul><hr><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><blockquote><p>“这里的<code>env_tf.cp0_epc</code>字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为<code>e_entry</code>，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。”<br>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的<code>env_tf.cp0_epc</code>存储的是物理地址还是虚拟地址?</p></blockquote><p>PC 是CPU中用于记录当前运行代码在内存中的地址的寄存器，而我们知道，CPU发出的地址并不是物理地址，而是当前运行进程地址空间中的虚拟地址。而此处的<code>env_tf.cp0_epc</code>指示了进程恢复运行时 PC 应恢复到的位置，也就是说它记录的是一个<strong>PC值</strong>，基于我们上面的推理可知，<code>env_tf.cp0_epc</code>是一个<strong>虚拟地址</strong>。</p><p>而指导书也佐证了这一点（逃</p><p><img src="va.png" alt="是虚拟地址"></p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><blockquote><p>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用）涉及的<code>do_syscall()</code>函数将在 Lab4 中实现。 </p></blockquote><p>在文件<code>genex.S</code>中有如下宏：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> <span class="keyword">BUILD_HANDLER </span>exception handler</span><br><span class="line">NESTED(handle_\exception, TF_SIZE + <span class="number">8</span>, <span class="built_in">zero</span>)</span><br><span class="line">    <span class="keyword">move </span>   <span class="built_in">a0</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">addiu </span>  <span class="built_in">sp</span>, <span class="built_in">sp</span>, -<span class="number">8</span></span><br><span class="line">    <span class="keyword">jal </span>    \handler</span><br><span class="line">    <span class="keyword">addiu </span>  <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">j </span>      ret_from_exception</span><br><span class="line">END(handle_\exception)</span><br><span class="line"><span class="meta">.endm</span></span><br></pre></td></tr></table></figure><p>该宏具体的作用是构建一个对给定<code>exception</code>调用对应的<code>handler</code>函数的汇编函数。该宏在<code>genex.S</code>中有如下使用：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BUILD_HANDLER </span>tlb do_tlb_refill</span><br><span class="line"><span class="keyword">BUILD_HANDLER </span>mod do_tlb_mod</span><br><span class="line"><span class="keyword">BUILD_HANDLER </span>sys do_syscall // 未实现</span><br></pre></td></tr></table></figure><p>那么对于这道思考题，我们不难做出回答：对于0号异常，对应的<code>handler</code>的具体实现在<code>genex.S</code>中的汇编函数<code>handle_int</code>中：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, <span class="built_in">zero</span>)</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_CAUSE</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t2</span>, CP0_STATUS</span><br><span class="line">    <span class="keyword">and </span>    <span class="built_in">t0</span>, <span class="built_in">t2</span></span><br><span class="line">    <span class="keyword">andi </span>   <span class="built_in">t1</span>, <span class="built_in">t0</span>, STATUS_IM4</span><br><span class="line">    <span class="keyword">bnez </span>   <span class="built_in">t1</span>, timer_irq</span><br><span class="line">    // TODO: handle other irqs</span><br><span class="line"><span class="symbol">timer_irq:</span></span><br><span class="line">    <span class="keyword">sw </span>     <span class="built_in">zero</span>, (KSEG1 <span class="title">| DEV_RTC_ADDRESS |</span> DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">    li      <span class="built_in">a0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="keyword">schedule</span></span><br><span class="line"><span class="keyword"></span>END(handle_int)</span><br></pre></td></tr></table></figure><p>而对于1号异常，<code>handler</code>的具体实现为<code>tlbex.c</code>中的<code>do_tlb_mod</code>函数；而对于2、3号异常，<code>handler</code>的具体实现为<code>tlbex.c</code>中的<code>do_tlb_refill</code>函数。</p><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><blockquote><p>阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出enable_irq 和 timer_irq 中每行汇编代码的作用。</p></blockquote><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">    li      <span class="built_in">t0</span>, (STATUS_CU0 <span class="title">| STATUS_IM4 |</span> STATUS_IEc) //状态位设置：(CP0使能<span class="title">|IM4中断使能|</span>中断使能)，将该值写入<span class="built_in">t0</span>寄存器</span><br><span class="line">    <span class="keyword">mtc0 </span>   <span class="built_in">t0</span>, CP0_STATUS // 将状态位设置写入CP0的STATUS寄存器</span><br><span class="line">    <span class="keyword">jr </span>     <span class="built_in">ra</span> //  函数返回</span><br><span class="line">END(enable_irq)</span><br></pre></td></tr></table></figure><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">timer_irq:</span> <span class="comment">/*in function `handle_int`*/</span></span><br><span class="line">    <span class="keyword">sw </span>     <span class="built_in">zero</span>, (KSEG1 <span class="title">| DEV_RTC_ADDRESS |</span> DEV_RTC_INTERRUPT_ACK) // 写该地址响应中断</span><br><span class="line">    li      <span class="built_in">a0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="keyword">schedule </span>// 和上一条指令结合起来等价于<span class="keyword">schedule(0)(即不yield使能，调用schedule函数)</span></span><br></pre></td></tr></table></figure><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><blockquote><p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p></blockquote><p>其实指导书已经把流程梳理的比较清楚了，我在这里再归纳一下。</p><h4 id="step1-异常分发"><a href="#step1-异常分发" class="headerlink" title="step1:异常分发"></a>step1:异常分发</h4><p>当硬件产生时钟中断时，处理器进入异常分发程序，具体到我们本次实验中就是<code>entry.S</code>中的<code>exc_gen_entry</code>:</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">exc_gen_entry:</span></span><br><span class="line">    SAVE_ALL // 保存上下文到异常栈</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_CAUSE</span><br><span class="line">    <span class="keyword">andi </span>   <span class="built_in">t0</span>, <span class="number">0x7c</span> // <span class="number">0</span>b<span class="string">&#x27;0111_1100取6-2位异常码</span></span><br><span class="line"><span class="string">    lw      t0, exception_handlers(t0)</span></span><br><span class="line"><span class="string">    jr      t0 // 跳转到相应的异常处理程序</span></span><br></pre></td></tr></table></figure><h4 id="step2-进一步细分中断类型"><a href="#step2-进一步细分中断类型" class="headerlink" title="step2:进一步细分中断类型"></a>step2:进一步细分中断类型</h4><p>在上面的异常分发程序中，我们获取到的异常码为0(也就是中断异常)，在获取异常码后，便跳转到<code>genex.S</code>中相应的异常处理程序<code>handle_int</code>来进一步细分中断异常的类型:</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, <span class="built_in">zero</span>)</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_CAUSE</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t2</span>, CP0_STATUS</span><br><span class="line">    <span class="keyword">and </span>    <span class="built_in">t0</span>, <span class="built_in">t2</span></span><br><span class="line">    <span class="keyword">andi </span>   <span class="built_in">t1</span>, <span class="built_in">t0</span>, STATUS_IM4</span><br><span class="line">    <span class="keyword">bnez </span>   <span class="built_in">t1</span>, timer_irq // 检查到是时钟中断</span><br><span class="line">    // TODO: handle other irqs</span><br><span class="line"><span class="symbol">timer_irq:</span></span><br><span class="line">    <span class="keyword">sw </span>     <span class="built_in">zero</span>, (KSEG1 <span class="title">| DEV_RTC_ADDRESS |</span> DEV_RTC_INTERRUPT_ACK) // 写该地址响应中断</span><br><span class="line">    li      <span class="built_in">a0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="keyword">schedule </span>// 跳转到<span class="keyword">schedule函数进行进程的调度</span></span><br><span class="line"><span class="keyword"></span>END(handle_int)</span><br></pre></td></tr></table></figure><h4 id="step3-进程调度"><a href="#step3-进程调度" class="headerlink" title="step3:进程调度"></a>step3:进程调度</h4><p>调用<code>sched.c</code>中的<code>schedule</code>函数，通过时间片轮转算法来实现进程的调度。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>本次实验的<strong>代码填空</strong>在仔细阅读指导书以及相关注释代码的前提下是较为简单和流畅的。我在完成思考题的时候遇到的一个难点是：在完成<code>Thinking3.5</code>时直接用<code>grep</code>指令搜索相关的<code>handler</code>函数的实现未果，翻了半天，最后发现实验代码使用宏来简化了各个<code>handler</code>函数的编写。而这一部分在指导书最后的代码导读部分也有提，果然指导书的各个部分的内容都不能放过啊。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本次实验在完成并理解了LAB2的基础上，完成难度并不高。原因在我看来主要在于LAB3和LAB2在很多地方都可以进行自然而然的类比和迁移，最有代表性的就是LAB3中的<code>env_free_list</code>和<code>env_sched_list</code>与LAB2中的<code>page_free_list</code>。在LAB2的完成过程中，我较为熟练掌握了链表宏的结构以及使用方法，从而在LAB3中的链表操作相关逻辑的编写过程中就显得比LAB2时更加得心应手。而LAB3中也涉及了很多LAB2中实现函数诸如<code>page_alloc</code>和<code>page_insert</code>之类的。深入理解LAB2实验代码是顺利完成LAB3的一个重要条件。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab0 实验报告</title>
      <link href="/2023/03/02/OS-Lab0/"/>
      <url>/2023/03/02/OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>题目太长，就不摘抄了。</p><p>对比 $Untracked.txt$ 和 $Stage.txt$ 的内容，可以发现，在对 $README.txt$ 文件进行 <code>git add</code> 之前，该文件处于 <code>Untracked</code> 状态，而在添加后则处于<strong>待提交</strong>状态，这说明该文件已经被添加到暂存区了。</p><p>观察 $Modified.txt$ 文件可以看到修改文件后，$README.txt$ 处于 <code>Modified</code> 状态，这是工作区文件和暂存区文件不一致造成的。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><p>题目如下：</p><p><em>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</em></p><img src="0.10.png" alt="示意图" width="500"/><p>箭头 $Add the file$ 对应的git命令是：<code>git add</code>；<br>箭头 $Stage the file$ 对应的git命令依然是：<code>git add [filename]</code>；<br>箭头 $Commit$ 对应的git命令是：<code>git commit</code>。</p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><p>题目如下：<br><em>1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</em></p><p><em>2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当<br>使用什么命令将其恢复？</em></p><p><em>3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下<br>将其移出暂存区？</em></p><p>解答如下：</p><ol><li>此时该文件只是被从工作区删除，而仍旧存在于暂存区。我们只需要使用命令 <code>git checkout -- print.c</code>将文件从暂存区恢复至工作区即可。</li><li>此时工作区和暂存区的 $print.c$ 文件均已被删除，此时应当使用命令 <code>git reset HEAD print.c</code>来将文件从HEAD所指的提交版本中将文件恢复；</li><li>使用命令 <code>git rm --chached hello.txt</code> 命令以从暂存区删除 $hello.txt$。</li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>题目太长不摘抄了。</p><p>通过使用<code>git reset --hard &lt;hash&gt;</code>可以回退到哈希值指定的版本，而使用<code>git reset --hard HEAD^</code>则可以回退到前一个版本。</p><p><strong>注意！</strong> 在使用<code>git reset --hard</code>时需要注意是否将当前工作区内容做了提交，因为该命令会将工作区 <strong>所有未提交内容覆盖掉</strong>。</p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p>题目如下：</p><p><em>执行如下命令, 并查看结果：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> first</span><br><span class="line"><span class="built_in">echo</span> second &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> third &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p>最终的运行结果为：</p><ul><li>命令行打印了一行 $first$ 字符串；</li><li>$output.txt$ 文件内容为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">third</span><br><span class="line">forth</span><br></pre></td></tr></table></figure><p>并没有出现字符串$second$，这是由于命令<code>echo third &gt; output.txt</code>覆写了命令<code>echo second &gt; output.txt</code>向文件写入的内容。</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>题目如下：</p><p><em>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），<br>将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，<br>将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最<br>后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问<br>题: echo echo Shell Start 与 echo ‘echo Shell Start’效果是否有区别; echo echo<br>$c&gt;file1 与 echo ‘echo $c&gt;file1’效果是否有区别.</em></p><p><img src="0.14.png" alt="文件内容"></p><p>对于 $command$ 文件的编写，我们只需要先使用<code>touch</code>命令创建$test$文件，并将图0.14所示的文件每一行的字符串(设为$string[i]$)以命令<code>echo &#39;string&#39; &gt;&gt; test</code>向 $test$文件写入即可。</p><p><code>echo echo Shell start</code>命令的效果与<code>echo &#39;echo Shell Start&#39;</code> 命令的效果是<strong>相同</strong>的，而 <code>echo echo $c&gt;file1</code> 与 <code>echo &#39;echo $c&gt;file&#39;</code>命令效果则是<strong>不同的</strong>，前者的作用是利用重定向向 $file1$ 文件写入字符串 $echo $c$，而后者则是在命令行中输出字符串 $echo $c&gt;file$。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>本次实验中唯一卡住我的是 $Exercise 0.4$ 的第二问。说句实话对于 $Makefile$ 的介绍我觉得无论是Pre教程还是实验指导书都显得有些<strong>贫瘠</strong>。</p><p>在查阅了一些相关资料之后发现这题其实很好做，大致流程就是用<code>gcc -c</code>把子目录里面的两个C文件编译成.o文件，再在顶层目录把子目录下两个.o文件用<code>gcc -o</code>连接成可执行文件。</p><p>其中比较难的有两个点：</p><p>其一是如何让处于<code>./code</code>文件夹下面的两个包含了<code>&lt;fibo.h&gt;</code>头文件的.c文件在编译时知道自己要包含的头文件在<code>../include</code>文件夹下面，这个问题可以通过gcc的<code>-I</code>参数解决，具体代码如下(./code/Makefile)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于fibo.c</span></span><br><span class="line">gcc -c fibo.o fibo.c -I ../include</span><br><span class="line"><span class="comment"># 对于main.c</span></span><br><span class="line">gcc -c main.o main.c -I ../include</span><br></pre></td></tr></table></figure><p>其二则时如何让顶层目录下的<code>make</code>命令调用子目录的<code>make</code>命令，这个问题我是通过<code>make</code>命令的<code>-C</code>参数解决的，具体代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C ./code/</span><br></pre></td></tr></table></figure><p>这个命令会调用<code>./code</code>文件夹下的<code>make</code>命令。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>这次Lab0的体会用一句话概括就是：<strong>好用的工具太多，我会的太少</strong>。从git到make再到vim，直到做完这个lab感觉也只是懂得一些皮毛的东西，应该有很多有意思的特性值得去深挖。</p><p>没什么多说的，<strong>keep humble keep hungry</strong>，虚心学下去就好。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> bash </tag>
            
            <tag> git </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(二)------页面设置</title>
      <link href="/2023/02/05/LaTeX2/"/>
      <url>/2023/02/05/LaTeX2/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文章：<br><a href="https://zhuanlan.zhihu.com/p/56405574">LaTeX入门(七)——页面设置</a></p><h2 id="页面大小设置：geometry"><a href="#页面大小设置：geometry" class="headerlink" title="页面大小设置：geometry"></a>页面大小设置：geometry</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepacage</span>&#123;geometry&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置页面长宽</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;paperheight=22cm, paperwidth=10cm&#125; <span class="comment">% 当然，也可以直接指定长宽数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心定位</span></span><br><span class="line"><span class="comment">% 版心位置参数有：left, right, top, bottom</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;left=2cm&#125;</span><br><span class="line"><span class="comment">% 版心居中参数有：vcentering(竖直居中), hcentering(水平居中), centering(水平、数值均居中)</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;centering&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心大小</span></span><br><span class="line"><span class="comment">% 版心大小参数有：textheight, textwidth</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;textheight=20cm&#125;</span><br></pre></td></tr></table></figure><h2 id="页眉页脚：fancyhdr"><a href="#页眉页脚：fancyhdr" class="headerlink" title="页眉页脚：fancyhdr"></a>页眉页脚：fancyhdr</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125;</span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125; </span><br><span class="line"><span class="comment">% fancy参数为自定义模式，plain参数为没有页眉，页脚中部放置页码</span></span><br><span class="line"><span class="comment">% empty参数不显示页眉和页脚，headings参数没有页脚页眉包含章节标题和页码</span></span><br><span class="line"><span class="comment">% myheadings有点复杂，摘录如下：</span></span><br><span class="line"><span class="comment">% 不显示页脚；页眉中显示页码，偶数页的页码显示在右侧，奇数页的页码显示在左侧；除了页码之外，还显示用户自定义的信息；还有一个例外，在每一章的第一页，不显示页眉，页脚显示居中的页码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\fancyhf</span>&#123;&#125; <span class="comment">% 清除页眉和页脚，若不使用这个命令，默认的“plain”样式会被使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 自定义页眉页脚内容</span></span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125; <span class="comment">%左边页眉，依此类推</span></span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\cfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rfoot</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 也可以使用这种方式：</span></span><br><span class="line"><span class="keyword">\fancyhead</span>[LE,RO]&#123;Overleaf&#125;</span><br><span class="line"><span class="keyword">\fancyhead</span>[RE,LO]&#123;Guides and tutorials&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[CE,CO]&#123;<span class="keyword">\leftmark</span>&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[LE,RO]&#123;<span class="keyword">\thepage</span>&#125;</span><br><span class="line"><span class="comment">% 其中：E代表偶数页，O代表奇数页，L代表左侧，R代表右侧，C代表居中</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>如果同时使用了<code>geometry</code>和<code>fancyhdr</code>宏包，那么一定要把<code>\usepackage&#123;fancyhdr&#125;</code>及相应的页眉、页脚设置写在<code>\usepackage&#123;geometry&#125;</code>的前面，否则会出现奇怪的错误</li><li>如果要在正文中使用<code>\maketitle</code>，那么那一页的页面格式会自动变回原来的页面格式。需要在<code>\maketitle</code>后加上一句<code>\thispagestyle&#123;fancy&#125;</code></li><li>取消页眉线可以使用指令：<code>\renewcommand\headrulewidth&#123;0pt&#125;</code></li></ul><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(一)------用LaTeX写一篇论文的基础框架</title>
      <link href="/2023/02/04/latex1/"/>
      <url>/2023/02/04/latex1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>可以分为导言区和正文区</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\document</span></span><br><span class="line"><span class="comment">% 导言区，用于用\usepacage指令引入各种宏包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 正文区，用于编写正文</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="文章层次结构"><a href="#文章层次结构" class="headerlink" title="文章层次结构"></a>文章层次结构</h2><h3 id="层次结构的划分"><a href="#层次结构的划分" class="headerlink" title="层次结构的划分"></a>层次结构的划分</h3><p>层次结构主要使用<code>\section&#123;&#125;</code>和<code>\subsection&#123;&#125;</code>命令来进行标记。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;一级标题&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\subsection</span>&#123;二级标题&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">\subsubsection</span>&#123;三级标题&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">\subsection</span>&#123;第二个二级标题&#125;</span><br></pre></td></tr></table></figure><h3 id="利用已经划分好的层次结构生成目录"><a href="#利用已经划分好的层次结构生成目录" class="headerlink" title="利用已经划分好的层次结构生成目录"></a>利用已经划分好的层次结构生成目录</h3><p>在经过上述命令的使用构造好章节结构后，可以使用<code>\tableofcontents</code>命令在指定的位置生成目录。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成目录页</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在latex中插入图片需要使用graphicx宏包，建议使用形式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=8cm]&#123;图片.jpg&#125; <span class="comment">% 大括号内应为图片相对于latex文件的路径</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;图片标题&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p>其中，[<strong>htbp</strong>]的作用是自动选择插入图片的最优位置，<strong>\centering</strong>设置让图片居中，[<strong>width=8cm</strong>]设置了图片的宽度为8cm，**\caption{}**用于设置图片的标题。</p><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>表格插入较为麻烦，可以直接使用<a href="https://www.tablesgenerator.com/#">Create LaTeX tables online – TablesGenerator.com</a>进行表格代码生成</p><h2 id="参考文献交叉引用"><a href="#参考文献交叉引用" class="headerlink" title="参考文献交叉引用"></a>参考文献交叉引用</h2><p>文末参考文献使用<strong>thebibliography环境</strong>编写，具体语法如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line"><span class="comment">%此处&#123;99&#125;的含义为环境内参考文献数目最多为99</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;article1&#125;参考文献1</span><br><span class="line">    <span class="comment">%此处指令后大括号为文中交叉引用的key</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;yinyong1&#125;引用1</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure><p>而若要在文中相应位置进行交叉引用，则应当使用<code>\cite</code>指令，使用例如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们会插入第一个引用<span class="keyword">\cite</span>&#123;article1&#125;，第二个则在这里<span class="keyword">\cite</span>&#123;yinyong1&#125;。</span><br></pre></td></tr></table></figure><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;数据分析&gt; NumPy初见</title>
      <link href="/2023/01/28/NumPy%E5%88%9D%E8%A7%81/"/>
      <url>/2023/01/28/NumPy%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-学习笔记"><a href="#NumPy-学习笔记" class="headerlink" title="NumPy 学习笔记"></a>NumPy 学习笔记</h1><p>from 《利用Python进行数据分析》</p><hr><p>numpy导包语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><p>两个重要的attribute:<br><code>dtype</code>:表示数组容纳的数据类型；<br><code>shape</code>:元组，指示着数组的形状</p><h3 id="ndarray的生成"><a href="#ndarray的生成" class="headerlink" title="ndarray的生成"></a>ndarray的生成</h3><p>生成方法：</p><p>总的来说可以按照接受参数分为四类：<br>构造型：<br><code>np.array()</code>：接受参数为元组、列表或者其他参数；<br>“按需供给型”：<br>接受参数为<code>shape</code>和<code>dtype</code>，具体代表有：<br><code>np.ones()</code>、<code>np.zeros()</code>;<br>“like”型:<br>接受一个ndarray实例并按要求生成一个形似其的ndarray实例，具体代表有：<br><code>np.oneslike()</code>、<code>np.zeros_like</code>；<br>特征矩阵型：<br>生成指定大小（N x N）的特征矩阵。<br><code>np.eye()</code>、<code>np.inentity()</code>.</p><h3 id="ndarray数据类型"><a href="#ndarray数据类型" class="headerlink" title="ndarray数据类型"></a>ndarray数据类型</h3><p>重要方法：<code>np.astype()</code>接受参数为一个dtype，功能为强制转换数组数据类型。</p><h3 id="NumPy数组算数"><a href="#NumPy数组算数" class="headerlink" title="NumPy数组算数"></a>NumPy数组算数</h3><p>NumPy所支持的数组算数是定义在两个<strong>尺寸相同</strong>d的ndarray之间的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设arr, arr1为两个尺寸相同的ndarray的引用,NumPy支持以下写法：</span></span><br><span class="line">a = arr*arr</span><br><span class="line">b = arr - arr</span><br><span class="line">c = <span class="number">1</span> / arr</span><br><span class="line">d = arr ** <span class="number">0.5</span> // 次幂</span><br><span class="line">e = arr &gt; arr1 // e为一个布尔值数组</span><br></pre></td></tr></table></figure><h3 id="基础索引与切片"><a href="#基础索引与切片" class="headerlink" title="基础索引与切片"></a>基础索引与切片</h3><p>一个值得注意的事实是，ndarray的切片是这个数组的一个视图，也就是说，当对切片进行操作时，这个操作会映射到原数组上；</p><p>如果希望得到切片的一个副本，那么需要调用：<code>np.copy()</code>方法，这个方法返回一个ndarray的副本。</p><p>具体索引/切片形式和python内建数据结构相似，形如<code>x:y</code>这样的形式包含在中括号中。</p><p>对于多维数组（以三维数组arr3d为例），其索引形式为：arr3d[甲,乙,丙]，从左至右依次选定中括号层次由外向内的系列对象。</p><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>fact1 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 若运行：</span></span><br><span class="line">boolean = (names == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># 会返回: array([False, True, True], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>fact2 :<br>索引数组可以传入布尔数组作为某个轴的索引参数。</p><h3 id="魔术索引-magic-index"><a href="#魔术索引-magic-index" class="headerlink" title="魔术索引(magic index)"></a>魔术索引(magic index)</h3><h3 id="数组转置和转轴"><a href="#数组转置和转轴" class="headerlink" title="数组转置和转轴"></a>数组转置和转轴</h3><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>这个查书就好</p><h2 id="使用数组进行面向数组编程"><a href="#使用数组进行面向数组编程" class="headerlink" title="使用数组进行面向数组编程"></a>使用数组进行面向数组编程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>)</span><br><span class="line">xs, ys = np.meshgrid(points, points) <span class="comment"># meshgrid方法需要后期留意一下</span></span><br><span class="line">z = np.sqrt(xs**<span class="number">2</span> + ys**<span class="number">2</span>) </span><br></pre></td></tr></table></figure><p><code>np.where(cond, xarr, yarr)</code>方法可以被看做python三元表达式的向量化版本，其功能为：若cond中数组相应位置元素满足cond表达式，则用xarr对应元素替换，否则用yarr对应元素替换。</p><p>后续不再摘录书中方法，有必要去查numpy官方API文档即可。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
