<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAAOS-Lab0 实验报告</title>
      <link href="/2023/03/02/OS-Lab0/"/>
      <url>/2023/03/02/OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>题目太长，就不摘抄了。</p><p>对比 $Untracked.txt$ 和 $Stage.txt$ 的内容，可以发现，在对 $README.txt$ 文件进行 <code>git add</code> 之前，该文件处于 <code>Untracked</code> 状态，而在添加后则处于<strong>待提交</strong>状态，这说明该文件已经被添加到暂存区了。</p><p>观察 $Modified.txt$ 文件可以看到修改文件后，$README.txt$ 处于 <code>Modified</code> 状态，这是工作区文件和暂存区文件不一致造成的。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><p>题目如下：</p><p><em>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</em></p><img src="./OS-LAB0/0.10.png" alt="drawing" width="500"/><p>箭头 $Add the file$ 对应的git命令是：<code>git add</code>；<br>箭头 $Stage the file$ 对应的git命令依然是：<code>git add [filename]</code>；<br>箭头 $Commit$ 对应的git命令是：<code>git commit</code>。</p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><p>题目如下：<br><em>1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</em></p><p><em>2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当<br>使用什么命令将其恢复？</em></p><p><em>3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下<br>将其移出暂存区？</em></p><p>解答如下：</p><ol><li>此时该文件只是被从工作区删除，而仍旧存在于暂存区。我们只需要使用命令 <code>git checkout -- print.c</code>将文件从暂存区恢复至工作区即可。</li><li>此时工作区和暂存区的 $print.c$ 文件均已被删除，此时应当使用命令 <code>git reset HEAD print.c</code>来将文件从HEAD所指的提交版本中将文件恢复；</li><li>使用命令 <code>git rm --chached hello.txt</code> 命令以从暂存区删除 $hello.txt$。</li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>题目太长不摘抄了。</p><p>通过使用<code>git reset --hard &lt;hash&gt;</code>可以回退到哈希值指定的版本，而使用<code>git reset --hard HEAD^</code>则可以回退到前一个版本。</p><p><strong>注意！</strong> 在使用<code>git reset --hard</code>时需要注意是否将当前工作区内容做了提交，因为该命令会将工作区 <strong>所有未提交内容覆盖掉</strong>。</p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p>题目如下：</p><p><em>执行如下命令, 并查看结果：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> first</span><br><span class="line"><span class="built_in">echo</span> second &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> third &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p>最终的运行结果为：</p><ul><li>命令行打印了一行 $first$ 字符串；</li><li>$output.txt$ 文件内容为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">third</span><br><span class="line">forth</span><br></pre></td></tr></table></figure><p>并没有出现字符串$second$，这是由于命令<code>echo third &gt; output.txt</code>覆写了命令<code>echo second &gt; output.txt</code>向文件写入的内容。</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>题目如下：</p><p><em>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），<br>将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，<br>将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最<br>后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问<br>题: echo echo Shell Start 与 echo ‘echo Shell Start’效果是否有区别; echo echo<br>$c&gt;file1 与 echo ‘echo $c&gt;file1’效果是否有区别.</em></p><p><img src="./OS-LAB0/0.14.png" alt="文件内容"></p><p>对于 $command$ 文件的编写，我们只需要先使用<code>touch</code>命令创建$test$文件，并将图0.14所示的文件每一行的字符串(设为$string[i]$)以命令<code>echo &#39;string&#39; &gt;&gt; test</code>向 $test$文件写入即可。</p><p><code>echo echo Shell start</code>命令的效果与<code>echo &#39;echo Shell Start&#39;</code> 命令的效果是<strong>相同</strong>的，而 <code>echo echo $c&gt;file1</code> 与 <code>echo &#39;echo $c&gt;file&#39;</code>命令效果则是<strong>不同的</strong>，前者的作用是利用重定向向 $file1$ 文件写入字符串 $echo $c$，而后者则是在命令行中输出字符串 $echo $c&gt;file$。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>本次实验中唯一卡住我的是 $Exercise 0.4$ 的第二问。说句实话对于 $Makefile$ 的介绍我觉得无论是Pre教程还是实验指导书都显得有些<strong>贫瘠</strong>。</p><p>在查阅了一些相关资料之后发现这题其实很好做，大致流程就是用<code>gcc -c</code>把子目录里面的两个C文件编译成.o文件，再在顶层目录把子目录下两个.o文件用<code>gcc -o</code>连接成可执行文件。</p><p>其中比较难的有两个点：</p><p>其一是如何让处于<code>./code</code>文件夹下面的两个包含了<code>&lt;fibo.h&gt;</code>头文件的.c文件在编译时知道自己要包含的头文件在<code>../include</code>文件夹下面，这个问题可以通过gcc的<code>-I</code>参数解决，具体代码如下(./code/Makefile)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于fibo.c</span></span><br><span class="line">gcc -c fibo.o fibo.c -I ../include</span><br><span class="line"><span class="comment"># 对于main.c</span></span><br><span class="line">gcc -c main.o main.c -I ../include</span><br></pre></td></tr></table></figure><p>其二则时如何让顶层目录下的<code>make</code>命令调用子目录的<code>make</code>命令，这个问题我是通过<code>make</code>命令的<code>-C</code>参数解决的，具体代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C ./code/</span><br></pre></td></tr></table></figure><p>这个命令会调用<code>./code</code>文件夹下的<code>make</code>命令。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>这次Lab0的体会用一句话概括就是：<strong>好用的工具太多，我会的太少</strong>。从git到make再到vim，直到做完这个lab感觉也只是懂得一些皮毛的东西，应该有很多有意思的特性值得去深挖。</p><p>没什么多说的，<strong>keep humble keep hungry</strong>，虚心学下去就好。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> bash </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(二)------页面设置</title>
      <link href="/2023/02/05/LaTeX2/"/>
      <url>/2023/02/05/LaTeX2/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文章：<br><a href="https://zhuanlan.zhihu.com/p/56405574">LaTeX入门(七)——页面设置</a></p><h2 id="页面大小设置：geometry"><a href="#页面大小设置：geometry" class="headerlink" title="页面大小设置：geometry"></a>页面大小设置：geometry</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepacage</span>&#123;geometry&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置页面长宽</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;paperheight=22cm, paperwidth=10cm&#125; <span class="comment">% 当然，也可以直接指定长宽数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心定位</span></span><br><span class="line"><span class="comment">% 版心位置参数有：left, right, top, bottom</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;left=2cm&#125;</span><br><span class="line"><span class="comment">% 版心居中参数有：vcentering(竖直居中), hcentering(水平居中), centering(水平、数值均居中)</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;centering&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心大小</span></span><br><span class="line"><span class="comment">% 版心大小参数有：textheight, textwidth</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;textheight=20cm&#125;</span><br></pre></td></tr></table></figure><h2 id="页眉页脚：fancyhdr"><a href="#页眉页脚：fancyhdr" class="headerlink" title="页眉页脚：fancyhdr"></a>页眉页脚：fancyhdr</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125;</span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125; </span><br><span class="line"><span class="comment">% fancy参数为自定义模式，plain参数为没有页眉，页脚中部放置页码</span></span><br><span class="line"><span class="comment">% empty参数不显示页眉和页脚，headings参数没有页脚页眉包含章节标题和页码</span></span><br><span class="line"><span class="comment">% myheadings有点复杂，摘录如下：</span></span><br><span class="line"><span class="comment">% 不显示页脚；页眉中显示页码，偶数页的页码显示在右侧，奇数页的页码显示在左侧；除了页码之外，还显示用户自定义的信息；还有一个例外，在每一章的第一页，不显示页眉，页脚显示居中的页码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\fancyhf</span>&#123;&#125; <span class="comment">% 清除页眉和页脚，若不使用这个命令，默认的“plain”样式会被使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 自定义页眉页脚内容</span></span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125; <span class="comment">%左边页眉，依此类推</span></span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\cfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rfoot</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 也可以使用这种方式：</span></span><br><span class="line"><span class="keyword">\fancyhead</span>[LE,RO]&#123;Overleaf&#125;</span><br><span class="line"><span class="keyword">\fancyhead</span>[RE,LO]&#123;Guides and tutorials&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[CE,CO]&#123;<span class="keyword">\leftmark</span>&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[LE,RO]&#123;<span class="keyword">\thepage</span>&#125;</span><br><span class="line"><span class="comment">% 其中：E代表偶数页，O代表奇数页，L代表左侧，R代表右侧，C代表居中</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>如果同时使用了<code>geometry</code>和<code>fancyhdr</code>宏包，那么一定要把<code>\usepackage&#123;fancyhdr&#125;</code>及相应的页眉、页脚设置写在<code>\usepackage&#123;geometry&#125;</code>的前面，否则会出现奇怪的错误</li><li>如果要在正文中使用<code>\maketitle</code>，那么那一页的页面格式会自动变回原来的页面格式。需要在<code>\maketitle</code>后加上一句<code>\thispagestyle&#123;fancy&#125;</code></li><li>取消页眉线可以使用指令：<code>\renewcommand\headrulewidth&#123;0pt&#125;</code></li></ul><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(一)------用LaTeX写一篇论文的基础框架</title>
      <link href="/2023/02/04/latex1/"/>
      <url>/2023/02/04/latex1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>可以分为导言区和正文区</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\document</span></span><br><span class="line"><span class="comment">% 导言区，用于用\usepacage指令引入各种宏包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 正文区，用于编写正文</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="文章层次结构"><a href="#文章层次结构" class="headerlink" title="文章层次结构"></a>文章层次结构</h2><h3 id="层次结构的划分"><a href="#层次结构的划分" class="headerlink" title="层次结构的划分"></a>层次结构的划分</h3><p>层次结构主要使用<code>\section&#123;&#125;</code>和<code>\subsection&#123;&#125;</code>命令来进行标记。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;一级标题&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\subsection</span>&#123;二级标题&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">\subsubsection</span>&#123;三级标题&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">\subsection</span>&#123;第二个二级标题&#125;</span><br></pre></td></tr></table></figure><h3 id="利用已经划分好的层次结构生成目录"><a href="#利用已经划分好的层次结构生成目录" class="headerlink" title="利用已经划分好的层次结构生成目录"></a>利用已经划分好的层次结构生成目录</h3><p>在经过上述命令的使用构造好章节结构后，可以使用<code>\tableofcontents</code>命令在指定的位置生成目录。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成目录页</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在latex中插入图片需要使用graphicx宏包，建议使用形式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=8cm]&#123;图片.jpg&#125; <span class="comment">% 大括号内应为图片相对于latex文件的路径</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;图片标题&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p>其中，[<strong>htbp</strong>]的作用是自动选择插入图片的最优位置，<strong>\centering</strong>设置让图片居中，[<strong>width=8cm</strong>]设置了图片的宽度为8cm，**\caption{}**用于设置图片的标题。</p><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>表格插入较为麻烦，可以直接使用<a href="https://www.tablesgenerator.com/#">Create LaTeX tables online – TablesGenerator.com</a>进行表格代码生成</p><h2 id="参考文献交叉引用"><a href="#参考文献交叉引用" class="headerlink" title="参考文献交叉引用"></a>参考文献交叉引用</h2><p>文末参考文献使用<strong>thebibliography环境</strong>编写，具体语法如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line"><span class="comment">%此处&#123;99&#125;的含义为环境内参考文献数目最多为99</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;article1&#125;参考文献1</span><br><span class="line">    <span class="comment">%此处指令后大括号为文中交叉引用的key</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;yinyong1&#125;引用1</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure><p>而若要在文中相应位置进行交叉引用，则应当使用<code>\cite</code>指令，使用例如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们会插入第一个引用<span class="keyword">\cite</span>&#123;article1&#125;，第二个则在这里<span class="keyword">\cite</span>&#123;yinyong1&#125;。</span><br></pre></td></tr></table></figure><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;数据分析&gt; NumPy初见</title>
      <link href="/2023/01/28/NumPy%E5%88%9D%E8%A7%81/"/>
      <url>/2023/01/28/NumPy%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-学习笔记"><a href="#NumPy-学习笔记" class="headerlink" title="NumPy 学习笔记"></a>NumPy 学习笔记</h1><p>from 《利用Python进行数据分析》</p><hr><p>numpy导包语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><p>两个重要的attribute:<br><code>dtype</code>:表示数组容纳的数据类型；<br><code>shape</code>:元组，指示着数组的形状</p><h3 id="ndarray的生成"><a href="#ndarray的生成" class="headerlink" title="ndarray的生成"></a>ndarray的生成</h3><p>生成方法：</p><p>总的来说可以按照接受参数分为四类：<br>构造型：<br><code>np.array()</code>：接受参数为元组、列表或者其他参数；<br>“按需供给型”：<br>接受参数为<code>shape</code>和<code>dtype</code>，具体代表有：<br><code>np.ones()</code>、<code>np.zeros()</code>;<br>“like”型:<br>接受一个ndarray实例并按要求生成一个形似其的ndarray实例，具体代表有：<br><code>np.oneslike()</code>、<code>np.zeros_like</code>；<br>特征矩阵型：<br>生成指定大小（N x N）的特征矩阵。<br><code>np.eye()</code>、<code>np.inentity()</code>.</p><h3 id="ndarray数据类型"><a href="#ndarray数据类型" class="headerlink" title="ndarray数据类型"></a>ndarray数据类型</h3><p>重要方法：<code>np.astype()</code>接受参数为一个dtype，功能为强制转换数组数据类型。</p><h3 id="NumPy数组算数"><a href="#NumPy数组算数" class="headerlink" title="NumPy数组算数"></a>NumPy数组算数</h3><p>NumPy所支持的数组算数是定义在两个<strong>尺寸相同</strong>d的ndarray之间的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设arr, arr1为两个尺寸相同的ndarray的引用,NumPy支持以下写法：</span></span><br><span class="line">a = arr*arr</span><br><span class="line">b = arr - arr</span><br><span class="line">c = <span class="number">1</span> / arr</span><br><span class="line">d = arr ** <span class="number">0.5</span> // 次幂</span><br><span class="line">e = arr &gt; arr1 // e为一个布尔值数组</span><br></pre></td></tr></table></figure><h3 id="基础索引与切片"><a href="#基础索引与切片" class="headerlink" title="基础索引与切片"></a>基础索引与切片</h3><p>一个值得注意的事实是，ndarray的切片是这个数组的一个视图，也就是说，当对切片进行操作时，这个操作会映射到原数组上；</p><p>如果希望得到切片的一个副本，那么需要调用：<code>np.copy()</code>方法，这个方法返回一个ndarray的副本。</p><p>具体索引/切片形式和python内建数据结构相似，形如<code>x:y</code>这样的形式包含在中括号中。</p><p>对于多维数组（以三维数组arr3d为例），其索引形式为：arr3d[甲,乙,丙]，从左至右依次选定中括号层次由外向内的系列对象。</p><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>fact1 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 若运行：</span></span><br><span class="line">boolean = (names == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># 会返回: array([False, True, True], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>fact2 :<br>索引数组可以传入布尔数组作为某个轴的索引参数。</p><h3 id="魔术索引-magic-index"><a href="#魔术索引-magic-index" class="headerlink" title="魔术索引(magic index)"></a>魔术索引(magic index)</h3><h3 id="数组转置和转轴"><a href="#数组转置和转轴" class="headerlink" title="数组转置和转轴"></a>数组转置和转轴</h3><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>这个查书就好</p><h2 id="使用数组进行面向数组编程"><a href="#使用数组进行面向数组编程" class="headerlink" title="使用数组进行面向数组编程"></a>使用数组进行面向数组编程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>)</span><br><span class="line">xs, ys = np.meshgrid(points, points) <span class="comment"># meshgrid方法需要后期留意一下</span></span><br><span class="line">z = np.sqrt(xs**<span class="number">2</span> + ys**<span class="number">2</span>) </span><br></pre></td></tr></table></figure><p><code>np.where(cond, xarr, yarr)</code>方法可以被看做python三元表达式的向量化版本，其功能为：若cond中数组相应位置元素满足cond表达式，则用xarr对应元素替换，否则用yarr对应元素替换。</p><p>后续不再摘录书中方法，有必要去查numpy官方API文档即可。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
