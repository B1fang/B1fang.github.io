<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAAOS-Lab1 实验报告</title>
      <link href="/2023/04/11/OS-Lab1/"/>
      <url>/2023/04/11/OS-Lab1/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><blockquote><p>请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生 x86 工具链(<code>gcc</code>、<code>ld</code>、<code>readelf</code>、<code>objdump</code>等)和 MIPS 交叉编译工具链(带有 <code>mips-linux-gnu-</code>前缀)，重复其中的编译和解析过程，观察相应的结果，并解释其中向 <code>objdump</code> 传入的参数的含义。</p></blockquote><hr><p>首先，我们使用<code>objdump --help</code>命令来查看<code>-DS</code>参数的含义，输出结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-D, --disassemble-all    Display assembler contents of all sections</span><br><span class="line"><span class="comment">// 含义为展示所有section的汇编内容</span></span><br><span class="line">-S, --source             Intermix source code with disassembly</span><br><span class="line"><span class="comment">// 同时显示机器源码与反汇编得到的汇编代码</span></span><br></pre></td></tr></table></figure><p>也就是说，这里参数的含义是：<strong>展示二进制文件所有section的反汇编结果，并同时显示机器源码和反汇编得到的汇编代码</strong>。</p><p>使用原生x86工具链的操作流程与结果在指导书中已经十分清晰了，于是我在此不做复述，仅对使用<code>mips</code>交叉编译工具链的实验过程进行记录。</p><p>首先我在空文件夹下创建C文件<code>hello.c</code>，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对其使用命令<code>mips-linux-gnu-gcc -E hello.c &gt; cache1</code>，得到的预处理后的文件里只是出现了头文件的内容(只包含printf()的函数头)，并没有出现<code>printf()</code>函数本尊的身影，部分文件内容摘录如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">printf</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;hello.c&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再键入命令<code>mips-linux-gnu-gcc -c hello.c</code>对<code>hello.c</code>文件进行编译(不链接)，使用<code>mips-linux-gnu-objdump -DS hello.o &gt; cache1</code>进行反汇编，<code>cache1</code>中的<code>main</code>函数反汇编结果为：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">7</span> <span class="number">00000000</span> &lt;main&gt;:</span><br><span class="line"> <span class="number">8</span>    <span class="number">0</span>:   <span class="number">27</span>bdffe0        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">32</span></span><br><span class="line"> <span class="number">9</span>    <span class="number">4</span>:   afbf001c        <span class="keyword">sw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">10</span>    <span class="number">8</span>:   afbe0018        <span class="keyword">sw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">11</span>    c:   <span class="number">03</span>a<span class="symbol">0f</span>025        <span class="keyword">move </span>   <span class="built_in">s8</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="number">12</span>   <span class="number">10</span>:   <span class="number">3</span>c1c0000        <span class="keyword">lui </span>    <span class="built_in">gp</span>,<span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>   <span class="number">14</span>:   <span class="number">279</span>c0000        <span class="keyword">addiu </span>  <span class="built_in">gp</span>,<span class="built_in">gp</span>,<span class="number">0</span></span><br><span class="line"><span class="number">14</span>   <span class="number">18</span>:   afbc0010        <span class="keyword">sw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">15</span>   <span class="number">1</span>c:   <span class="number">3</span>c020000        <span class="keyword">lui </span>    <span class="built_in">v0</span>,<span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>   <span class="number">20</span>:   <span class="number">24440000</span>        <span class="keyword">addiu </span>  <span class="built_in">a0</span>,<span class="built_in">v0</span>,<span class="number">0</span></span><br><span class="line"><span class="number">17</span>   <span class="number">24</span>:   <span class="number">8</span>f820000        <span class="keyword">lw </span>     <span class="built_in">v0</span>,<span class="number">0</span>(<span class="built_in">gp</span>)</span><br><span class="line"><span class="number">18</span>   <span class="number">28</span>:   <span class="number">0040</span>c825        <span class="keyword">move </span>   <span class="built_in">t9</span>,<span class="built_in">v0</span></span><br><span class="line"><span class="number">19</span>   <span class="number">2</span>c:   <span class="number">0320</span>f809        <span class="keyword">jalr </span>   <span class="built_in">t9</span></span><br><span class="line"><span class="number">20</span>   <span class="number">30</span>:   <span class="number">00000000</span>        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="number">21</span>   <span class="number">34</span>:   <span class="number">8</span>fdc0010        <span class="keyword">lw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">s8</span>)</span><br><span class="line"><span class="number">22</span>   <span class="number">38</span>:   <span class="number">00001025</span>        <span class="keyword">move </span>   <span class="built_in">v0</span>,<span class="built_in">zero</span></span><br><span class="line"><span class="number">23</span>   <span class="number">3</span>c:   <span class="number">03</span>c0e825        <span class="keyword">move </span>   <span class="built_in">sp</span>,<span class="built_in">s8</span></span><br><span class="line"><span class="number">24</span>   <span class="number">40</span>:   <span class="number">8</span>fbf001c        <span class="keyword">lw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">25</span>   <span class="number">44</span>:   <span class="number">8</span>fbe0018        <span class="keyword">lw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">26</span>   <span class="number">48</span>:   <span class="number">27</span>bd0020        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">32</span></span><br><span class="line"><span class="number">27</span>   <span class="number">4</span>c:   <span class="number">03</span>e00008        <span class="keyword">jr </span>     <span class="built_in">ra</span></span><br><span class="line"><span class="number">28</span>   <span class="number">50</span>:   <span class="number">00000000</span>        <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>而键入命令<code>mips-linux-gnu-gcc -o hello hello.c</code><br>，对源文件<code>hello.c</code>进行编译和链接。再执行命令<code>mips-linux-gnu-objdump -DS hello &gt; cache3</code>，其中的<code>main</code>函数结果反汇编结果如下：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">380</span> <span class="number">004006</span>e0 &lt;main&gt;:</span><br><span class="line"><span class="number">381</span>   <span class="number">4006</span>e0:       <span class="number">27</span>bdffe0        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">32</span></span><br><span class="line"><span class="number">382</span>   <span class="number">4006</span>e4:       afbf001c        <span class="keyword">sw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">383</span>   <span class="number">4006</span>e8:       afbe0018        <span class="keyword">sw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">384</span>   <span class="number">4006</span>ec:       <span class="number">03</span>a<span class="symbol">0f</span>025        <span class="keyword">move </span>   <span class="built_in">s8</span>,<span class="built_in">sp</span></span><br><span class="line"><span class="number">385</span>   <span class="number">4006</span>f0:       <span class="number">3</span>c1c0042        <span class="keyword">lui </span>    <span class="built_in">gp</span>,<span class="number">0x42</span></span><br><span class="line"><span class="number">386</span>   <span class="number">4006</span>f4:       <span class="number">279</span>c9010        <span class="keyword">addiu </span>  <span class="built_in">gp</span>,<span class="built_in">gp</span>,-<span class="number">28656</span></span><br><span class="line"><span class="number">387</span>   <span class="number">4006</span>f8:       afbc0010        <span class="keyword">sw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">388</span>   <span class="number">4006</span>fc:       <span class="number">3</span>c020040        <span class="keyword">lui </span>    <span class="built_in">v0</span>,<span class="number">0x40</span></span><br><span class="line"><span class="number">389</span>   <span class="number">400700</span>:       <span class="number">24440830</span>        <span class="keyword">addiu </span>  <span class="built_in">a0</span>,<span class="built_in">v0</span>,<span class="number">2096</span></span><br><span class="line"><span class="number">390</span>   <span class="number">400704</span>:       <span class="number">8</span>f828030        <span class="keyword">lw </span>     <span class="built_in">v0</span>,-<span class="number">32720</span>(<span class="built_in">gp</span>)</span><br><span class="line"><span class="number">391</span>   <span class="number">400708</span>:       <span class="number">0040</span>c825        <span class="keyword">move </span>   <span class="built_in">t9</span>,<span class="built_in">v0</span></span><br><span class="line"><span class="number">392</span>   <span class="number">40070</span>c:       <span class="number">0320</span>f809        <span class="keyword">jalr </span>   <span class="built_in">t9</span></span><br><span class="line"><span class="number">393</span>   <span class="number">400710</span>:       <span class="number">00000000</span>        <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="number">394</span>   <span class="number">400714</span>:       <span class="number">8</span>fdc0010        <span class="keyword">lw </span>     <span class="built_in">gp</span>,<span class="number">16</span>(<span class="built_in">s8</span>)</span><br><span class="line"><span class="number">395</span>   <span class="number">400718</span>:       <span class="number">00001025</span>        <span class="keyword">move </span>   <span class="built_in">v0</span>,<span class="built_in">zero</span></span><br><span class="line"><span class="number">396</span>   <span class="number">40071</span>c:       <span class="number">03</span>c0e825        <span class="keyword">move </span>   <span class="built_in">sp</span>,<span class="built_in">s8</span></span><br><span class="line"><span class="number">397</span>   <span class="number">400720</span>:       <span class="number">8</span>fbf001c        <span class="keyword">lw </span>     <span class="built_in">ra</span>,<span class="number">28</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">398</span>   <span class="number">400724</span>:       <span class="number">8</span>fbe0018        <span class="keyword">lw </span>     <span class="built_in">s8</span>,<span class="number">24</span>(<span class="built_in">sp</span>)</span><br><span class="line"><span class="number">399</span>   <span class="number">400728</span>:       <span class="number">27</span>bd0020        <span class="keyword">addiu </span>  <span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">32</span></span><br><span class="line"><span class="number">400</span>   <span class="number">40072</span>c:       <span class="number">03</span>e00008        <span class="keyword">jr </span>     <span class="built_in">ra</span></span><br><span class="line"><span class="number">401</span>   <span class="number">400730</span>:       <span class="number">00000000</span>        <span class="keyword">nop</span></span><br></pre></td></tr></table></figure><p>可以观察到：首先，<code>main</code>函数入口在链接后被分配了在<code>0x4006e0</code>的地址，其次，被用于存储跳转到<code>printf()</code>函数的地址的<code>t9</code>寄存器的值也不再是默认值了。</p><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><blockquote><p>思考下述问题：</p><p>-尝试使用我们编写的 <code>readelf</code> 程序，解析之前在 <code>target</code> 目录下生成的内核ELF文件。</p><p>-也许你会发现我们编写的 <code>readelf</code> 程序是不能解析 <code>readelf</code> 文件本身的，而我们刚才介绍的系统工具 <code>readelf</code> 则可以解析，这是为什么呢？(hint: 尝试使用 <code>readelf -h</code>，并阅读 <code>tools/readelf</code> 目录下的 <code>Makefile</code>，观察 <code>readelf</code> 与 <code>hello</code> 的不同)</p></blockquote><hr><p>使用命令<code>./readelf ../../target/mos</code>对内核ELF文件进行解析，得到如下结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0:0x0</span><br><span class="line">1:0x80010000</span><br><span class="line">2:0x80011df0</span><br><span class="line">3:0x80011e08</span><br><span class="line">4:0x80011e20</span><br><span class="line">5:0x0</span><br><span class="line">6:0x0</span><br><span class="line">7:0x0</span><br><span class="line">8:0x0</span><br><span class="line">9:0x0</span><br><span class="line">10:0x0</span><br><span class="line">11:0x0</span><br><span class="line">12:0x0</span><br><span class="line">13:0x0</span><br><span class="line">14:0x0</span><br><span class="line">15:0x0</span><br><span class="line">16:0x0</span><br><span class="line">17:0x0</span><br></pre></td></tr></table></figure><p>对于我们编写的<code>readelf</code>程序无法解析<code>readelf</code>文件本身的原因，我先放结论：这是因为<strong>我们编写的readelf程序只能够解析32位的ELF文件，而我们编写的readelf程序本身是64位的ELF文件，因此无法被解析。</strong></p><p>首先，我们使用<code>readelf -h</code>命令分别对<code>hello</code>和<code>readelf</code>文件进行解析，得到的结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF32</span><br><span class="line"></span><br><span class="line"><span class="comment">// readelf</span></span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br></pre></td></tr></table></figure><p>而目录下<code>Makefile</code>中对<code>hello</code>的编译命令为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello: hello.c</span></span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span> -m32 -static -g</span><br></pre></td></tr></table></figure><p>其中<code>-m32</code>参数的作用是在64位操作系统下编译生成32位可执行文件，这更加佐证了我的观点：hello是一个32位的可执行文件。</p><p>为了进一步佐证我的观点，我编写了一个完全相同的<code>hello2.c</code>文件，并使用<code>gcc -o hello2 hello2.c</code>，接着用<code>./readelf hello2</code>命令尝试对<code>hello2</code>文件进行解析，未果。再次使用<code>readelf -h hello2</code>，得到如下结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ELF 头：</span><br><span class="line">  Magic：   <span class="number">7f</span> <span class="number">45</span> <span class="number">4</span>c <span class="number">46</span> <span class="number">02</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  类别:                              ELF64</span><br></pre></td></tr></table></figure><p>可知，我们编写的<code>readelf</code>程序无法解析自身的原因是该程序只能解析32位的elf文件。</p><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><blockquote><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000(其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址)，但实验操作系统的内核入口并没有放在上电启动地址，而是按照<strong>内存布局图</strong>放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？(Hint: <strong>思考实验中启动过程的两阶段分别由谁执行</strong>)</p></blockquote><hr><p>根据指导书附录，我们可以知道，真实操作系统启动的时候，在内核被加载运行之前是会经过两个由<code>bootloader</code>控制进行的阶段(stage1，stage2)的。其中，stage1完成的工作为：基础的硬件初始化，为stage2初始化RAM，载入stage2到RAM，<strong>设置堆栈</strong>并跳转到stage2入口；而stage2完成的工作为：初始化该阶段所需的硬件设备，载入内核和根文件系统，<strong>最后</strong>才会为内核设置启动参数并跳转到内核入口。</p><p>也就是说，真实的操作系统的启动流程中，内核并不是在一开始就直接被加载到内存上，而是先由<code>bootloader</code>逐步对硬件设备进行控制与初始化，在硬件初始化完成后再将硬件的控制权交给操作系统的。</p><p>而我们的实验编写的MOS操作系统的运行和现实不同的一点是，它是在GXemul仿真器上运行的。而GXemul仿真器支持直接加载ELF格式的内核文件，也就是说我们在实验中，因为仿真器已经提供了本由<code>bootloader</code>的引导功能(即硬件已经被初始化)，更通俗点讲，就是需要<code>bootloader</code>程序去做的 <strong>“盘活硬件”的脏活儿</strong> 已经不用做了，启动的时候也不需要从 <strong><code>bootloader</code>程序的入口</strong> 开始运行了。所以在启动时我们只需要通过<code>Linker Script</code>保证将内核ELF文件加载到内存的合适位置上就好。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>我认为本次实验就代码实现上并不算困难。那么难点在哪里呢？我想难主要难在 <strong>“带着镣铐跳舞”</strong>。本次实验让我明白操作系统实验不是像以往课程实验那样，自己从头到尾实现一个程序，而是在别人的代码框架上做补全。这就要求我设计程序的基础不是我的架构设计，而是这套代码本身的架构设计。我的程序设计是建立在对涉及到的相关代码提供的“基础设施”以及设计思路的基础之上的，而不是我想怎么来就怎么来。</p><h2 id="我的心得体会"><a href="#我的心得体会" class="headerlink" title="我的心得体会"></a>我的心得体会</h2><p>跨多个代码文件进行阅读并总结思考编码方案，这对我这样的没有接触过大项目的人而言是一个很有挑战性的过程，希望我的工程设计和把控能力能在本学期的操作系统课程中取得锻炼和进步。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab2 实验报告</title>
      <link href="/2023/04/11/OS-Lab2/"/>
      <url>/2023/04/11/OS-Lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><blockquote><p>Q:在编写的 C 程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？</p></blockquote><p><strong>A</strong>:</p><ul><li>在编写的C程序中，指针变量中存储的地址是虚拟地址；</li><li>MIPS汇编程序中lw和sw使用的也是虚拟地址。</li></ul><hr><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><blockquote><p>Q1:从可重用性的角度，阐述用宏来实现链表的好处。<br>Q2:查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异</p></blockquote><p><strong>A1</strong>:</p><p>用宏实现链表的好处可以通过将其与通过函数实现进行对比来体现。就我们实验中<code>Page</code>组成的链表为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span>&#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        pp_link&#123;</span></span><br><span class="line"><span class="comment">            struct Page *le_next;</span></span><br><span class="line"><span class="comment">            struct Page **le_prev;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设我们有一个链表头<code>struct Page* head</code>指向的链表，若我们要编写一个在该链表元素<code>listelm</code>后插入元素<code>elm</code>的函数，我们应当做如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_after</span><span class="params">(<span class="keyword">struct</span> Page* listelm, <span class="keyword">struct</span> Page* elm)</span>;</span><br></pre></td></tr></table></figure><p>而若我们定义另一种链表单元如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_Page</span>&#123;</span></span><br><span class="line">    Page_LIST_entry_t pp_link;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        pp_link&#123;</span></span><br><span class="line"><span class="comment">            struct Page *le_next;</span></span><br><span class="line"><span class="comment">            struct Page **le_prev;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    u_long some_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个插入代码就无法在该类型上复用了。而考虑宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field)                                                    \</span></span><br><span class="line"><span class="meta">        do &#123;                                                                                       \</span></span><br><span class="line"><span class="meta">                (elm)-&gt;field.le_prev = (listelm)-&gt;field.le_prev;                                   \</span></span><br><span class="line"><span class="meta">                LIST_NEXT((elm), field) = (listelm);                                               \</span></span><br><span class="line"><span class="meta">                *(listelm)-&gt;field.le_prev = (elm);                                                 \</span></span><br><span class="line"><span class="meta">                (listelm)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field);                               \</span></span><br><span class="line"><span class="meta">        &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>首先无需考虑链表的<strong>类型命名</strong>，也无需考虑链表的<strong>指针域命名</strong>(传入替换即可)，更无需考虑和插入操作无关的除指针域结构体之外的<strong>数据域组成</strong>，复用性大大提高。</p><p><strong>A2</strong>:</p><p><strong>插入操作：</strong></p><p>单向链表在进行<strong>给定节点前插</strong>的操作时，由于无法通过给定结点访问到<strong>前序节点</strong>的指针域，因此需要对链表从头进行一个事件复杂度为<code>O(n)</code>的遍历，找到前序节点，才能完成前插操作；<br>而循环链表和双向链表因为指针域中多了<strong>指向前序节点后向指针的二级指针</strong>，因此只通过给定节点就可以访问到前序节点的后续指针，因此可以以<code>O(1)</code>的效率完成前插。</p><p>而循环链表的头节点指针域是由一对分别指向链表头部和尾部的指针组成的，因此在执行尾插时无需像双向链表和单向链表一样进行复杂度为<code>O(n)</code>的遍历。</p><p><strong>删除操作：</strong></p><p>依然来看单向链表。如果希望删除单向链表中的任意给定节点，需要的操作是将前序节点的后向指针指向给定节点的后续节点，这依然牵扯到前序节点指针域的访问，因此删除操作也需要<code>O(n)</code>的遍历，而双向链表和循环链表则具有<code>O(1)</code>的复杂度。</p><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><blockquote><p>Q:请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125;* pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125; lh_first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">    u_short pp_ref;</span><br><span class="line">    &#125;* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A</strong>:<br>答案是<strong>C选项</strong>。<code>Page_list</code>结构体中只存了一个指向链表第一个元素的<code>lh_first</code>指针，而阅读代码我们可以知道，<code>Page_list</code>指向的<code>Page</code>链表单元的结构是:名为<code>pp_link</code>的指针域和标记页面引用次数的数据域<code>pp_ref</code>，其中<code>pp_link</code>内包含后向一级指针<code>le_next</code>和前向二级指针<code>le_prev</code>。</p><hr><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><blockquote><p>Q1:请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。<br>Q2:请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</p></blockquote><p><strong>A1:</strong><br>引入虚拟内存的核心目的在于：为每个进程提供一个<strong>独立的内存视图</strong>。也就是说，每个进程都有自己独立的地址空间，仅凭借虚拟地址无法完成到物理地址的索引，通过<code>ASID</code>来判断该va属于哪个地址空间就十分必要了。</p><p><strong>A2:</strong></p><p><code>ASID</code>段的位数为6，也就是说理论上R3000可以容纳不同的地址空间的最大数量为<code>2^6=64</code>个。</p><p>而若当前同时存在的地址空间超过64时，会由操作系统进行<strong>ASID flushing</strong>。具体地讲，就是：所有任务的ASID被取消分配(de-assigned)，TLB被刷新；当每个任务被重新输入(re-entered)时，会被赋予新的<code>ASID</code>。<strong>这一过程是不常发生的</strong>。</p><hr><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><blockquote><p>Q1:tlb_invalidate 和 tlb_out 的调用关系？<br>Q2:请用一句话概括 tlb_invalidate 的作用。<br>Q3:逐行解释 tlb_out 中的汇编代码。</p></blockquote><p><strong>A1:</strong><br><code>tlb_out</code>是被<code>tlb_invalidate</code>调用的。</p><p><strong>A2:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tlb_invalidate(u_int asid, u_long va);</span><br></pre></td></tr></table></figure><p>用于删除TLB中<code>asid</code>指定的地址空间下，<code>va</code>所对应虚拟页面的表项。</p><p><strong>A3:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line"> .<span class="built_in">set</span> noreorder</span><br><span class="line">        mfc0    t0, CP0_ENTRYHI <span class="comment">// 保存现场</span></span><br><span class="line">        mtc0    a0, CP0_ENTRYHI <span class="comment">// 将`Key`写入`ENTRYHI`</span></span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        tlbp <span class="comment">// 在TLB中查找Key对应的表项</span></span><br><span class="line">        nop</span><br><span class="line">        nop</span><br><span class="line">        mfc0    t1, CP0_INDEX <span class="comment">// 将查找结果写入t1寄存器</span></span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">        bltz    t1, NO_SUCH_ENTRY <span class="comment">// 若未查找到(index &lt; 0), 则直接返回，若找到，进行下述流程</span></span><br><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">        mtc0    zero, CP0_ENTRYHI  <span class="comment">// 向`ENTRYHI`写入0</span></span><br><span class="line">        mtc0    zero, CP0_ENTRYLO0 <span class="comment">// 向`ENTRYLO`写入0</span></span><br><span class="line">        nop</span><br><span class="line">        tlbwi <span class="comment">// 将`INDEX`指定的表项的`KEY`和`VALUE`全置0</span></span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">        mtc0    t0, CP0_ENTRYHI <span class="comment">// 恢复现场</span></span><br><span class="line">        j       ra <span class="comment">// 函数返回</span></span><br><span class="line">END(tlb_out)</span><br></pre></td></tr></table></figure><p>解答如上。</p><hr><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><blockquote><p>Q1:简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。<br>Q2:简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</p></blockquote><p><strong>A1:</strong><br><strong>地址空间大小:</strong> x86 的地址空间是 32 位或 64 位，而 MIPS 的地址空间通常是 32 位。这意味着 x86 可以支持更大的内存容量。<br><strong>缓存一致性协议</strong>：x86 使用缓存一致性协议（如MESI协议），用于维护多个CPU之间的缓存一致性。而 MIPS 通常不包括这样的协议，这意味着在多CPU系统中，需要使用额外的硬件或软件来实现缓存一致性。</p><p><strong>A2:</strong><br><strong>地址空间大小</strong>：RISC-V 的地址空间可以是 32 位或 64 位，而 MIPS 的地址空间通常是 32 位。这意味着 RISC-V 可以支持更大的内存容量。<br><strong>页面大小</strong>：RISC-V 支持多种页面大小，包括 4KB、8KB、16KB、32KB、64KB、128KB、256KB 和 512KB。而 MIPS 可能只支持某些特定的页面大小，比如 4KB 和 16KB。</p><hr><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><blockquote><p>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表<strong>索引</strong>都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。<br>现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：<br>Q1:三级页表页目录的基地址。<br>Q2:映射到页目录自身的页目录项（自映射）。</p></blockquote><p><strong>A1:</strong></p><p>单个页面大小为<code>4KB</code>，则二级页表区域所占的空间大小为<code>4KB * 512 * 512 = 1GB</code>，一级页表区域所占空间大小为<code>4KB * 512 = 2MB</code>。我们不妨进行改写，二级页表基地址为<code>PT2base = PTbase</code>，一级页表基地址为 <code>PT1base</code>，而页目录基地址为<code>PDbase</code>。则可知<code>PT2base = PT1base + 2M * (PT1base / 512G)</code>，而<code>PDbase = PT2base + 4K * ((PT2base - PT1base) / 1G)</code>。</p><p><strong>A2:</strong><br>设该页目录项的地址为<code>PDitem</code>，则有<code>PDitem = PT2base + 8 * ((PDbase - PT2base) / 2M)</code>。</p><hr><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><p>本次实验的难点主要可以概括为以下几点：</p><h3 id="虚拟地址vs物理地址"><a href="#虚拟地址vs物理地址" class="headerlink" title="虚拟地址vs物理地址"></a>虚拟地址vs物理地址</h3><p>在完成本次实验的过程中，尽管实验代码已经在<code>pmap.h</code>和<code>mmu.h</code>为我们配备好了如下各种在本次实验的<code>kseg0</code>段上，虚拟地址与物理地址互相转化的内联函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2ppn</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2kva</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">va2pa</span><span class="params">(Pde *pgdir, u_long va)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无需在实验过程中为各种转化的具体实现抓耳挠腮，只需调用就好。但难点就在于我在完成实验的过程中需要对<code>虚拟地址</code>和<code>物理地址</code>斤斤计较。我在实验中总结的经验是：编写代码的我们在使用指针时是站在<strong>程序员视角</strong>的，也就是说我们操纵的<strong>一切指针</strong>都存储着将来这段程序对应进程下的虚拟地址，而物理地址则是一个我们需要通过特殊手段转化得到的数据。</p><p>本次实验中需要注意页目录项中存储的<strong>页表基地址</strong>和页表项中存储的<strong>页基地址</strong>均为物理地址。</p><h3 id="理解整个内存管理体系的结构"><a href="#理解整个内存管理体系的结构" class="headerlink" title="理解整个内存管理体系的结构"></a>理解整个内存管理体系的结构</h3><h4 id="页控制块和空闲链表"><a href="#页控制块和空闲链表" class="headerlink" title="页控制块和空闲链表"></a>页控制块和空闲链表</h4><p><strong>页控制块</strong>是<code>pages</code>指针指向的一片连续的<code>Page</code>结构体，每一个<code>Page</code>结构体映射着一个物理页框。</p><p><strong>空闲链表</strong>是以<code>page_free_list</code>为表头的一个双向链表，主要作用是将<code>pages</code>数组中所有空闲页面控制块串联起来，方便空闲页面的分配。</p><h4 id="页表项PTE和页目录项PDE"><a href="#页表项PTE和页目录项PDE" class="headerlink" title="页表项PTE和页目录项PDE"></a>页表项PTE和页目录项PDE</h4><p>首先<code>grep</code>一下可以发现在<code>mmu.h</code>里面有<code>typedef u_long Pde;</code>以及<code>typedef u_long Pte;</code>，可知这二者本质上是32位无符号整数。</p><p>而其结构也值得注意。指导书中给出的PDE结构图如下：</p><p><img src="pde.png" alt="PDE"></p><p>其实这张图还挺有迷惑性的，让人第一眼以为要取出这里的页表基地址需要：<code>address = pde &gt;&gt; 12</code>，然而当我看到<code>mmu.h</code>如下的宏我明白了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure><p>原来只需要低12位清零就好了，也就是说<code>PDE</code>和<code>PTE</code>中存储的物理地址要取得，是需要将低十二位清理，而并不是右移12位。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>在照着指导书进行实验代码编写受阻时，不妨向前翻一两页，很有可能会找到漏读的关键信息。</li><li><strong>指导书不能只囫囵吞枣读一遍！指导书不能只囫囵吞枣读一遍！指导书不能只囫囵吞枣读一遍！</strong></li><li>学习新概念时，不仅要记住这个概念长什么样，还要<strong>理解这个概念为什么长这样</strong>。就拿这次实验举个例子，我在写物理内存管理这一部分的时候就有很多疑惑：为什么同时有<code>pages</code>和<code>page_free_list</code>两个变量在管理页面控制块？而且为什么明明是一片连续的结构体数组，结构体里面还套了个链表的指针域，这玩意怎么一会儿数组一会儿链表的？这些问题在后面写虚拟内存管理的那部分的时候得到了解答，原来链表和数组的形式并不冲突，在<code>pages</code>数组上穿起链表是为了更高效地检索和获取空闲的物理页面，便于后续的页面分配工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab3 实验报告</title>
      <link href="/2023/04/11/OS-Lab3/"/>
      <url>/2023/04/11/OS-Lab3/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><blockquote><p>请结合 MOS 中的页目录自映射应用解释代码中<code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V</code>的含义。</p></blockquote><p>在<strong>MOS中的页目录自映射应用</strong>中提到：<u>而 MOS 中，将页表和页目录映射到了用户空间中的 0x7fc00000-0x80000000（共 4MB）区域，这意味着 MOS 中允许在用户态下通过 UVPT 访问当前进程的页表和页目录。</u>结合<code>mmu.h</code>中的宏定义<code>#define UVPT (ULIM - PDMAP)</code>，我们可以得知<code>UVPT</code>即为用户地址空间（虚存）中起<strong>始页表项的地址</strong>。</p><p>设映射到页目录自身的表项为页目录的第<code>i</code>项，页目录基地址为<code>base1</code>，页表基地址为<code>UVPT</code>基于自映射关系，我们可以得出如下关系式：</p><p><img src="expr.png" alt="公式"></p><p>解得：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = UVPT &gt;&gt; <span class="number">22</span>;</span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line">i = PDX(UVPT);</span><br></pre></td></tr></table></figure><p>基于上述分析不难理解，这条语句是将页目录的起始物理地址自映射到对应的页目录项。</p><hr><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><blockquote><p><code>elf_load_seg</code>以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code>。请你找到与之相关的<code>data</code>这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></blockquote><p><strong>来源</strong>：<br>在<code>include/elf.h</code>中可以找到<code>typedef int (*elf_mapper_t)(void *data, u_long va, size_t offset, u_int perm, const void *src,size_t len);</code>这样一条语句。可知<code>void *data</code>这一参数的来源是<code>elf_mapper_t</code>这一函数指针类型的形参列表。</p><p><strong>作用</strong>：<br>在<code>env.c</code>中的<code>load_icode</code>函数中对<code>elf_load_seg</code>有如下调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e)</span><br></pre></td></tr></table></figure><p>在形参<code>void *data</code>的位置传入了进程控制块指针<code>e</code>。进一步地，我们阅读<code>load_icode_mapper</code>的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    page_alloc(&amp;p);</span><br><span class="line">    <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *dst = (<span class="type">void</span> *)page2kva(p) + offset;</span><br><span class="line">        <span class="built_in">memcpy</span>(dst, src, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid,p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知<code>env</code>这个结构控制块指针在<code>load_icode_mapper</code>这个回调函数里的作用是为<code>page_insert</code>函数提供了参数<code>env-&gt;env_pgdir</code>和<code>env-&gt;env_asid</code>。在我看来，<code>elf_load_seg</code>是一个被要求<strong>满足多种调用需求的函数</strong>，而对不同调用需求的满足则是通过传入不同的<code>mapper</code>回调函数和<code>data</code>函数指针来实现的。而又因为需求不同，传入<code>data</code>指针的类型也会存在差异，因此，采用以<code>void</code>类型传入，在对应的<code>mapper</code>回调函数中进行相应的转型可以极大程度上提升<code>elf_load_seg</code>函数的<strong>可复用性</strong>。</p><p>没有这个参数是<strong>万万不能</strong>的，因为这样就无法满足回调函数的参数需求了。</p><hr><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><blockquote><p>结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</p></blockquote><ul><li>如果段的虚拟地址与页面边界不对齐，需要将二进制文件的前一个页面映射到虚拟地址空间中。偏移量为 <code>offset = va - ROUNDDOWN(va, BY2PG)</code>。</li><li>如果二进制文件大小小于一个页面，则需要将该页面映射到虚拟地址空间中。此时，需要使用<code>map_page</code>回调函数来分配和映射物理页面。</li><li>如果二进制文件大小大于一个页面，则需要将文件的每一页映射到虚拟地址空间中。同样需要使用<code>map_page</code>回调函数来进行物理页面映射。</li><li>如果二进制文件大小小于段的内存大小，则需要继续分配和映射页面，直到达到段的内存大小为止。</li></ul><hr><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><blockquote><p>“这里的<code>env_tf.cp0_epc</code>字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为<code>e_entry</code>，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。”<br>思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的<code>env_tf.cp0_epc</code>存储的是物理地址还是虚拟地址?</p></blockquote><p>PC 是CPU中用于记录当前运行代码在内存中的地址的寄存器，而我们知道，CPU发出的地址并不是物理地址，而是当前运行进程地址空间中的虚拟地址。而此处的<code>env_tf.cp0_epc</code>指示了进程恢复运行时 PC 应恢复到的位置，也就是说它记录的是一个<strong>PC值</strong>，基于我们上面的推理可知，<code>env_tf.cp0_epc</code>是一个<strong>虚拟地址</strong>。</p><p>而指导书也佐证了这一点（逃</p><p><img src="va.png" alt="是虚拟地址"></p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><blockquote><p>试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用）涉及的<code>do_syscall()</code>函数将在 Lab4 中实现。 </p></blockquote><p>在文件<code>genex.S</code>中有如下宏：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.macro</span> <span class="keyword">BUILD_HANDLER </span>exception handler</span><br><span class="line">NESTED(handle_\exception, TF_SIZE + <span class="number">8</span>, <span class="built_in">zero</span>)</span><br><span class="line">    <span class="keyword">move </span>   <span class="built_in">a0</span>, <span class="built_in">sp</span></span><br><span class="line">    <span class="keyword">addiu </span>  <span class="built_in">sp</span>, <span class="built_in">sp</span>, -<span class="number">8</span></span><br><span class="line">    <span class="keyword">jal </span>    \handler</span><br><span class="line">    <span class="keyword">addiu </span>  <span class="built_in">sp</span>, <span class="built_in">sp</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">j </span>      ret_from_exception</span><br><span class="line">END(handle_\exception)</span><br><span class="line"><span class="meta">.endm</span></span><br></pre></td></tr></table></figure><p>该宏具体的作用是构建一个对给定<code>exception</code>调用对应的<code>handler</code>函数的汇编函数。该宏在<code>genex.S</code>中有如下使用：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BUILD_HANDLER </span>tlb do_tlb_refill</span><br><span class="line"><span class="keyword">BUILD_HANDLER </span>mod do_tlb_mod</span><br><span class="line"><span class="keyword">BUILD_HANDLER </span>sys do_syscall // 未实现</span><br></pre></td></tr></table></figure><p>那么对于这道思考题，我们不难做出回答：对于0号异常，对应的<code>handler</code>的具体实现在<code>genex.S</code>中的汇编函数<code>handle_int</code>中：</p><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, <span class="built_in">zero</span>)</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t0</span>, CP0_CAUSE</span><br><span class="line">    <span class="keyword">mfc0 </span>   <span class="built_in">t2</span>, CP0_STATUS</span><br><span class="line">    <span class="keyword">and </span>    <span class="built_in">t0</span>, <span class="built_in">t2</span></span><br><span class="line">    <span class="keyword">andi </span>   <span class="built_in">t1</span>, <span class="built_in">t0</span>, STATUS_IM4</span><br><span class="line">    <span class="keyword">bnez </span>   <span class="built_in">t1</span>, timer_irq</span><br><span class="line">    // TODO: handle other irqs</span><br><span class="line"><span class="symbol">timer_irq:</span></span><br><span class="line">    <span class="keyword">sw </span>     <span class="built_in">zero</span>, (KSEG1 <span class="title">| DEV_RTC_ADDRESS |</span> DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">    li      <span class="built_in">a0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">j </span>      <span class="keyword">schedule</span></span><br><span class="line"><span class="keyword"></span>END(handle_int)</span><br></pre></td></tr></table></figure><p>而对于1号异常，<code>handler</code>的具体实现为<code>tlbex.c</code>中的<code>do_tlb_mod</code>函数；而对于2、3号异常，<code>handler</code>的具体实现为<code>tlbex.c</code>中的<code>do_tlb_refill</code>函数。</p><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><blockquote><p>阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出enable_irq 和 timer_irq 中每行汇编代码的作用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">    li      t0, (STATUS_CU0 | STATUS_IM4 | STATUS_IEc) <span class="comment">//状态位设置：(CP0使能|IM4中断使能|中断使能)，将该值写入t0寄存器</span></span><br><span class="line">    mtc0    t0, CP0_STATUS <span class="comment">// 将状态位设置写入CP0的STATUS寄存器</span></span><br><span class="line">    jr      ra <span class="comment">//  函数返回</span></span><br><span class="line">END(enable_irq)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer_irq: <span class="comment">/*in function `handle_int`*/</span></span><br><span class="line">    sw      zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK) <span class="comment">// 写该地址响应中断</span></span><br><span class="line">    li      a0, <span class="number">0</span></span><br><span class="line">    j       schedule <span class="comment">// 和上一条指令结合起来等价于schedule(0)(即不yield使能，调用schedule函数)</span></span><br></pre></td></tr></table></figure><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><blockquote><p>阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p></blockquote><p>其实指导书已经把流程梳理的比较清楚了，我在这里再归纳一下。</p><h4 id="step1-异常分发"><a href="#step1-异常分发" class="headerlink" title="step1:异常分发"></a>step1:异常分发</h4><p>当硬件产生时钟中断时，处理器进入异常分发程序，具体到我们本次实验中就是<code>entry.S</code>中的<code>exc_gen_entry</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exc_gen_entry:</span><br><span class="line">    SAVE_ALL <span class="comment">// 保存上下文到异常栈</span></span><br><span class="line">    mfc0    t0, CP0_CAUSE</span><br><span class="line">    andi    t0, <span class="number">0x7c</span> <span class="comment">// 0b&#x27;0111_1100取6-2位异常码</span></span><br><span class="line">    lw      t0, exception_handlers(t0)</span><br><span class="line">    jr      t0 <span class="comment">// 跳转到相应的异常处理程序</span></span><br></pre></td></tr></table></figure><h4 id="step2-进一步细分中断类型"><a href="#step2-进一步细分中断类型" class="headerlink" title="step2:进一步细分中断类型"></a>step2:进一步细分中断类型</h4><p>在上面的异常分发程序中，我们获取到的异常码为0(也就是中断异常)，在获取异常码后，便跳转到<code>genex.S</code>中相应的异常处理程序<code>handle_int</code>来进一步细分中断异常的类型:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">    mfc0    t0, CP0_CAUSE</span><br><span class="line">    mfc0    t2, CP0_STATUS</span><br><span class="line">    and     t0, t2</span><br><span class="line">    andi    t1, t0, STATUS_IM4</span><br><span class="line">    bnez    t1, timer_irq <span class="comment">// 检查到是时钟中断</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle other irqs</span></span><br><span class="line">timer_irq:</span><br><span class="line">    sw      zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK) <span class="comment">// 写该地址响应中断</span></span><br><span class="line">    li      a0, <span class="number">0</span></span><br><span class="line">    j       schedule <span class="comment">// 跳转到schedule函数进行进程的调度</span></span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><h4 id="step3-进程调度"><a href="#step3-进程调度" class="headerlink" title="step3:进程调度"></a>step3:进程调度</h4><p>调用<code>sched.c</code>中的<code>schedule</code>函数，通过时间片轮转算法来实现进程的调度。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>本次实验的<strong>代码填空</strong>在仔细阅读指导书以及相关注释代码的前提下是较为简单和流畅的。我在完成思考题的时候遇到的一个难点是：在完成<code>Thinking3.5</code>时直接用<code>grep</code>指令搜索相关的<code>handler</code>函数的实现未果，翻了半天，最后发现实验代码使用宏来简化了各个<code>handler</code>函数的编写。而这一部分在指导书最后的代码导读部分也有提，果然指导书的各个部分的内容都不能放过啊。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>本次实验在完成并理解了LAB2的基础上，完成难度并不高。原因在我看来主要在于LAB3和LAB2在很多地方都可以进行自然而然的类比和迁移，最有代表性的就是LAB3中的<code>env_free_list</code>和<code>env_sched_list</code>与LAB2中的<code>page_free_list</code>。在LAB2的完成过程中，我较为熟练掌握了链表宏的结构以及使用方法，从而在LAB3中的链表操作相关逻辑的编写过程中就显得比LAB2时更加得心应手。而LAB3中也涉及了很多LAB2中实现函数诸如<code>page_alloc</code>和<code>page_insert</code>之类的。深入理解LAB2实验代码是顺利完成LAB3的一个重要条件。</p>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAAOS-Lab0 实验报告</title>
      <link href="/2023/03/02/OS-Lab0/"/>
      <url>/2023/03/02/OS-Lab0/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>题目太长，就不摘抄了。</p><p>对比 $Untracked.txt$ 和 $Stage.txt$ 的内容，可以发现，在对 $README.txt$ 文件进行 <code>git add</code> 之前，该文件处于 <code>Untracked</code> 状态，而在添加后则处于<strong>待提交</strong>状态，这说明该文件已经被添加到暂存区了。</p><p>观察 $Modified.txt$ 文件可以看到修改文件后，$README.txt$ 处于 <code>Modified</code> 状态，这是工作区文件和暂存区文件不一致造成的。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><p>题目如下：</p><p><em>仔细看看0.10，思考一下箭头中的 add the file 、stage the file 和commit 分别对应的是 Git 里的哪些命令呢？</em></p><img src="0.10.png" alt="示意图" width="500"/><p>箭头 $Add the file$ 对应的git命令是：<code>git add</code>；<br>箭头 $Stage the file$ 对应的git命令依然是：<code>git add [filename]</code>；<br>箭头 $Commit$ 对应的git命令是：<code>git commit</code>。</p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><p>题目如下：<br><em>1. 代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？</em></p><p><em>2. 代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当<br>使用什么命令将其恢复？</em></p><p><em>3. 无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下<br>将其移出暂存区？</em></p><p>解答如下：</p><ol><li>此时该文件只是被从工作区删除，而仍旧存在于暂存区。我们只需要使用命令 <code>git checkout -- print.c</code>将文件从暂存区恢复至工作区即可。</li><li>此时工作区和暂存区的 $print.c$ 文件均已被删除，此时应当使用命令 <code>git reset HEAD print.c</code>来将文件从HEAD所指的提交版本中将文件恢复；</li><li>使用命令 <code>git rm --chached hello.txt</code> 命令以从暂存区删除 $hello.txt$。</li></ol><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>题目太长不摘抄了。</p><p>通过使用<code>git reset --hard &lt;hash&gt;</code>可以回退到哈希值指定的版本，而使用<code>git reset --hard HEAD^</code>则可以回退到前一个版本。</p><p><strong>注意！</strong> 在使用<code>git reset --hard</code>时需要注意是否将当前工作区内容做了提交，因为该命令会将工作区 <strong>所有未提交内容覆盖掉</strong>。</p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p>题目如下：</p><p><em>执行如下命令, 并查看结果：</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> first</span><br><span class="line"><span class="built_in">echo</span> second &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> third &gt; output.txt</span><br><span class="line"><span class="built_in">echo</span> forth &gt;&gt; output.txt</span><br></pre></td></tr></table></figure><p>最终的运行结果为：</p><ul><li>命令行打印了一行 $first$ 字符串；</li><li>$output.txt$ 文件内容为：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">third</span><br><span class="line">forth</span><br></pre></td></tr></table></figure><p>并没有出现字符串$second$，这是由于命令<code>echo third &gt; output.txt</code>覆写了命令<code>echo second &gt; output.txt</code>向文件写入的内容。</p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>题目如下：</p><p><em>使用你知道的方法（包括重定向）创建下图内容的文件（文件命名为 test），<br>将创建该文件的命令序列保存在 command 文件中，并将 test 文件作为批处理文件运行，<br>将运行结果输出至 result 文件中。给出 command 文件和 result 文件的内容，并对最<br>后的结果进行解释说明（可以从 test 文件的内容入手）. 具体实现的过程中思考下列问<br>题: echo echo Shell Start 与 echo ‘echo Shell Start’效果是否有区别; echo echo<br>$c&gt;file1 与 echo ‘echo $c&gt;file1’效果是否有区别.</em></p><p><img src="0.14.png" alt="文件内容"></p><p>对于 $command$ 文件的编写，我们只需要先使用<code>touch</code>命令创建$test$文件，并将图0.14所示的文件每一行的字符串(设为$string[i]$)以命令<code>echo &#39;string&#39; &gt;&gt; test</code>向 $test$文件写入即可。</p><p><code>echo echo Shell start</code>命令的效果与<code>echo &#39;echo Shell Start&#39;</code> 命令的效果是<strong>相同</strong>的，而 <code>echo echo $c&gt;file1</code> 与 <code>echo &#39;echo $c&gt;file&#39;</code>命令效果则是<strong>不同的</strong>，前者的作用是利用重定向向 $file1$ 文件写入字符串 $echo $c$，而后者则是在命令行中输出字符串 $echo $c&gt;file$。</p><h2 id="本次实验的难点"><a href="#本次实验的难点" class="headerlink" title="本次实验的难点"></a>本次实验的难点</h2><p>本次实验中唯一卡住我的是 $Exercise 0.4$ 的第二问。说句实话对于 $Makefile$ 的介绍我觉得无论是Pre教程还是实验指导书都显得有些<strong>贫瘠</strong>。</p><p>在查阅了一些相关资料之后发现这题其实很好做，大致流程就是用<code>gcc -c</code>把子目录里面的两个C文件编译成.o文件，再在顶层目录把子目录下两个.o文件用<code>gcc -o</code>连接成可执行文件。</p><p>其中比较难的有两个点：</p><p>其一是如何让处于<code>./code</code>文件夹下面的两个包含了<code>&lt;fibo.h&gt;</code>头文件的.c文件在编译时知道自己要包含的头文件在<code>../include</code>文件夹下面，这个问题可以通过gcc的<code>-I</code>参数解决，具体代码如下(./code/Makefile)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于fibo.c</span></span><br><span class="line">gcc -c fibo.o fibo.c -I ../include</span><br><span class="line"><span class="comment"># 对于main.c</span></span><br><span class="line">gcc -c main.o main.c -I ../include</span><br></pre></td></tr></table></figure><p>其二则时如何让顶层目录下的<code>make</code>命令调用子目录的<code>make</code>命令，这个问题我是通过<code>make</code>命令的<code>-C</code>参数解决的，具体代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C ./code/</span><br></pre></td></tr></table></figure><p>这个命令会调用<code>./code</code>文件夹下的<code>make</code>命令。</p><h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>这次Lab0的体会用一句话概括就是：<strong>好用的工具太多，我会的太少</strong>。从git到make再到vim，直到做完这个lab感觉也只是懂得一些皮毛的东西，应该有很多有意思的特性值得去深挖。</p><p>没什么多说的，<strong>keep humble keep hungry</strong>，虚心学下去就好。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> BUAA-OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> bash </tag>
            
            <tag> git </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(二)------页面设置</title>
      <link href="/2023/02/05/LaTeX2/"/>
      <url>/2023/02/05/LaTeX2/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考文章：<br><a href="https://zhuanlan.zhihu.com/p/56405574">LaTeX入门(七)——页面设置</a></p><h2 id="页面大小设置：geometry"><a href="#页面大小设置：geometry" class="headerlink" title="页面大小设置：geometry"></a>页面大小设置：geometry</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepacage</span>&#123;geometry&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置页面长宽</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;a4paper&#125;</span><br><span class="line"><span class="keyword">\geometry</span>&#123;paperheight=22cm, paperwidth=10cm&#125; <span class="comment">% 当然，也可以直接指定长宽数值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心定位</span></span><br><span class="line"><span class="comment">% 版心位置参数有：left, right, top, bottom</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;left=2cm&#125;</span><br><span class="line"><span class="comment">% 版心居中参数有：vcentering(竖直居中), hcentering(水平居中), centering(水平、数值均居中)</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;centering&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 版心大小</span></span><br><span class="line"><span class="comment">% 版心大小参数有：textheight, textwidth</span></span><br><span class="line"><span class="keyword">\geometry</span>&#123;textheight=20cm&#125;</span><br></pre></td></tr></table></figure><h2 id="页眉页脚：fancyhdr"><a href="#页眉页脚：fancyhdr" class="headerlink" title="页眉页脚：fancyhdr"></a>页眉页脚：fancyhdr</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125;</span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125; </span><br><span class="line"><span class="comment">% fancy参数为自定义模式，plain参数为没有页眉，页脚中部放置页码</span></span><br><span class="line"><span class="comment">% empty参数不显示页眉和页脚，headings参数没有页脚页眉包含章节标题和页码</span></span><br><span class="line"><span class="comment">% myheadings有点复杂，摘录如下：</span></span><br><span class="line"><span class="comment">% 不显示页脚；页眉中显示页码，偶数页的页码显示在右侧，奇数页的页码显示在左侧；除了页码之外，还显示用户自定义的信息；还有一个例外，在每一章的第一页，不显示页眉，页脚显示居中的页码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\fancyhf</span>&#123;&#125; <span class="comment">% 清除页眉和页脚，若不使用这个命令，默认的“plain”样式会被使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 自定义页眉页脚内容</span></span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125; <span class="comment">%左边页眉，依此类推</span></span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\cfoot</span>&#123;&#125;</span><br><span class="line"><span class="keyword">\rfoot</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 也可以使用这种方式：</span></span><br><span class="line"><span class="keyword">\fancyhead</span>[LE,RO]&#123;Overleaf&#125;</span><br><span class="line"><span class="keyword">\fancyhead</span>[RE,LO]&#123;Guides and tutorials&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[CE,CO]&#123;<span class="keyword">\leftmark</span>&#125;</span><br><span class="line"><span class="keyword">\fancyfoot</span>[LE,RO]&#123;<span class="keyword">\thepage</span>&#125;</span><br><span class="line"><span class="comment">% 其中：E代表偶数页，O代表奇数页，L代表左侧，R代表右侧，C代表居中</span></span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>如果同时使用了<code>geometry</code>和<code>fancyhdr</code>宏包，那么一定要把<code>\usepackage&#123;fancyhdr&#125;</code>及相应的页眉、页脚设置写在<code>\usepackage&#123;geometry&#125;</code>的前面，否则会出现奇怪的错误</li><li>如果要在正文中使用<code>\maketitle</code>，那么那一页的页面格式会自动变回原来的页面格式。需要在<code>\maketitle</code>后加上一句<code>\thispagestyle&#123;fancy&#125;</code></li><li>取消页眉线可以使用指令：<code>\renewcommand\headrulewidth&#123;0pt&#125;</code></li></ul><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速上手LaTeX(一)------用LaTeX写一篇论文的基础框架</title>
      <link href="/2023/02/04/latex1/"/>
      <url>/2023/02/04/latex1/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><p>可以分为导言区和正文区</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\document</span></span><br><span class="line"><span class="comment">% 导言区，用于用\usepacage指令引入各种宏包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="comment">% 正文区，用于编写正文</span></span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><h2 id="文章层次结构"><a href="#文章层次结构" class="headerlink" title="文章层次结构"></a>文章层次结构</h2><h3 id="层次结构的划分"><a href="#层次结构的划分" class="headerlink" title="层次结构的划分"></a>层次结构的划分</h3><p>层次结构主要使用<code>\section&#123;&#125;</code>和<code>\subsection&#123;&#125;</code>命令来进行标记。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\section</span>&#123;一级标题&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">\subsection</span>&#123;二级标题&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">\subsubsection</span>&#123;三级标题&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">\subsection</span>&#123;第二个二级标题&#125;</span><br></pre></td></tr></table></figure><h3 id="利用已经划分好的层次结构生成目录"><a href="#利用已经划分好的层次结构生成目录" class="headerlink" title="利用已经划分好的层次结构生成目录"></a>利用已经划分好的层次结构生成目录</h3><p>在经过上述命令的使用构造好章节结构后，可以使用<code>\tableofcontents</code>命令在指定的位置生成目录。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成目录页</span></span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在latex中插入图片需要使用graphicx宏包，建议使用形式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=8cm]&#123;图片.jpg&#125; <span class="comment">% 大括号内应为图片相对于latex文件的路径</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;图片标题&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p>其中，[<strong>htbp</strong>]的作用是自动选择插入图片的最优位置，<strong>\centering</strong>设置让图片居中，[<strong>width=8cm</strong>]设置了图片的宽度为8cm，**\caption{}**用于设置图片的标题。</p><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>表格插入较为麻烦，可以直接使用<a href="https://www.tablesgenerator.com/#">Create LaTeX tables online – TablesGenerator.com</a>进行表格代码生成</p><h2 id="参考文献交叉引用"><a href="#参考文献交叉引用" class="headerlink" title="参考文献交叉引用"></a>参考文献交叉引用</h2><p>文末参考文献使用<strong>thebibliography环境</strong>编写，具体语法如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line"><span class="comment">%此处&#123;99&#125;的含义为环境内参考文献数目最多为99</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;article1&#125;参考文献1</span><br><span class="line">    <span class="comment">%此处指令后大括号为文中交叉引用的key</span></span><br><span class="line">    <span class="keyword">\bibitem</span>&#123;yinyong1&#125;引用1</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure><p>而若要在文中相应位置进行交叉引用，则应当使用<code>\cite</code>指令，使用例如下：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们会插入第一个引用<span class="keyword">\cite</span>&#123;article1&#125;，第二个则在这里<span class="keyword">\cite</span>&#123;yinyong1&#125;。</span><br></pre></td></tr></table></figure><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&lt;数据分析&gt; NumPy初见</title>
      <link href="/2023/01/28/NumPy%E5%88%9D%E8%A7%81/"/>
      <url>/2023/01/28/NumPy%E5%88%9D%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<h1 id="NumPy-学习笔记"><a href="#NumPy-学习笔记" class="headerlink" title="NumPy 学习笔记"></a>NumPy 学习笔记</h1><p>from 《利用Python进行数据分析》</p><hr><p>numpy导包语句:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><p>两个重要的attribute:<br><code>dtype</code>:表示数组容纳的数据类型；<br><code>shape</code>:元组，指示着数组的形状</p><h3 id="ndarray的生成"><a href="#ndarray的生成" class="headerlink" title="ndarray的生成"></a>ndarray的生成</h3><p>生成方法：</p><p>总的来说可以按照接受参数分为四类：<br>构造型：<br><code>np.array()</code>：接受参数为元组、列表或者其他参数；<br>“按需供给型”：<br>接受参数为<code>shape</code>和<code>dtype</code>，具体代表有：<br><code>np.ones()</code>、<code>np.zeros()</code>;<br>“like”型:<br>接受一个ndarray实例并按要求生成一个形似其的ndarray实例，具体代表有：<br><code>np.oneslike()</code>、<code>np.zeros_like</code>；<br>特征矩阵型：<br>生成指定大小（N x N）的特征矩阵。<br><code>np.eye()</code>、<code>np.inentity()</code>.</p><h3 id="ndarray数据类型"><a href="#ndarray数据类型" class="headerlink" title="ndarray数据类型"></a>ndarray数据类型</h3><p>重要方法：<code>np.astype()</code>接受参数为一个dtype，功能为强制转换数组数据类型。</p><h3 id="NumPy数组算数"><a href="#NumPy数组算数" class="headerlink" title="NumPy数组算数"></a>NumPy数组算数</h3><p>NumPy所支持的数组算数是定义在两个<strong>尺寸相同</strong>d的ndarray之间的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设arr, arr1为两个尺寸相同的ndarray的引用,NumPy支持以下写法：</span></span><br><span class="line">a = arr*arr</span><br><span class="line">b = arr - arr</span><br><span class="line">c = <span class="number">1</span> / arr</span><br><span class="line">d = arr ** <span class="number">0.5</span> // 次幂</span><br><span class="line">e = arr &gt; arr1 // e为一个布尔值数组</span><br></pre></td></tr></table></figure><h3 id="基础索引与切片"><a href="#基础索引与切片" class="headerlink" title="基础索引与切片"></a>基础索引与切片</h3><p>一个值得注意的事实是，ndarray的切片是这个数组的一个视图，也就是说，当对切片进行操作时，这个操作会映射到原数组上；</p><p>如果希望得到切片的一个副本，那么需要调用：<code>np.copy()</code>方法，这个方法返回一个ndarray的副本。</p><p>具体索引/切片形式和python内建数据结构相似，形如<code>x:y</code>这样的形式包含在中括号中。</p><p>对于多维数组（以三维数组arr3d为例），其索引形式为：arr3d[甲,乙,丙]，从左至右依次选定中括号层次由外向内的系列对象。</p><h3 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h3><p>fact1 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment"># 若运行：</span></span><br><span class="line">boolean = (names == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># 会返回: array([False, True, True], dtype=bool)</span></span><br></pre></td></tr></table></figure><p>fact2 :<br>索引数组可以传入布尔数组作为某个轴的索引参数。</p><h3 id="魔术索引-magic-index"><a href="#魔术索引-magic-index" class="headerlink" title="魔术索引(magic index)"></a>魔术索引(magic index)</h3><h3 id="数组转置和转轴"><a href="#数组转置和转轴" class="headerlink" title="数组转置和转轴"></a>数组转置和转轴</h3><h2 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h2><p>这个查书就好</p><h2 id="使用数组进行面向数组编程"><a href="#使用数组进行面向数组编程" class="headerlink" title="使用数组进行面向数组编程"></a>使用数组进行面向数组编程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.01</span>)</span><br><span class="line">xs, ys = np.meshgrid(points, points) <span class="comment"># meshgrid方法需要后期留意一下</span></span><br><span class="line">z = np.sqrt(xs**<span class="number">2</span> + ys**<span class="number">2</span>) </span><br></pre></td></tr></table></figure><p><code>np.where(cond, xarr, yarr)</code>方法可以被看做python三元表达式的向量化版本，其功能为：若cond中数组相应位置元素满足cond表达式，则用xarr对应元素替换，否则用yarr对应元素替换。</p><p>后续不再摘录书中方法，有必要去查numpy官方API文档即可。</p><script src="https://utteranc.es/client.js"        repo="B1fang/B1fang.github.io"        issue-term="pathname"        label="Comment"        theme="github-light"        crossorigin="anonymous"        async></script>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
